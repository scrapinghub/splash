{
  "splash.args": {
    "name": null,
    "header": "splash.args",
    "content": "``splash.args`` is a table with incoming parameters. It contains\nmerged values from the orignal URL string (GET arguments) and\nvalues sent using ``application/json`` POST request.\n\nFor example, if you passed 'url' argument to a script using HTTP API,\nthen ``splash.args.url`` contains this URL.\n\nYou can also access ``splash.args`` using second, optional ``args`` argument\nof the ``main`` function:\n\n.. code-block:: lua\n\n    function main(splash, args)\n        local url = args.url\n        -- ...\n    end\n\nThe example above is the same as\n\n.. code-block:: lua\n\n    function main(splash)\n        local url = splash.args.url\n        -- ...\n    end\n\nUsing either ``args`` or :ref:`splash-args` is the preferred way to pass\nparameters to Splash scripts. An alternative way is to use string\nformatting to build a script with variables embedded.\nThere are two problems which make :ref:`splash-args` a better solution:\n\n1. data must be escaped somehow, so that it doesn't break a Lua script;\n2. embedding variables makes it impossible to use script cache efficiently\n   (see :ref:`save_args <arg-save-args>` and :ref:`load_args <arg-load-args>`\n   arguments of the HTTP API).",
    "short": null,
    "signature": null,
    "returns": null,
    "async": null,
    "details": null,
    "params": null
  },
  "splash.js_enabled": {
    "name": null,
    "header": "splash.js_enabled",
    "content": "Enable or disable execution of JavaSript code embedded in the page.\n\n**Signature:** ``splash.js_enabled = true/false``\n\nJavaScript execution is enabled by default.",
    "short": "Enable or disable execution of JavaSript code embedded in the page.",
    "signature": "splash.js_enabled = true/false",
    "returns": null,
    "async": null,
    "details": "JavaScript execution is enabled by default.",
    "params": null
  },
  "splash.private_mode_enabled": {
    "name": null,
    "header": "splash.private_mode_enabled",
    "content": "Enable or disable browser's private mode (incognito mode).\n\n**Signature:** ``splash.private_mode_enabled = true/false``\n\nPrivate mode is enabled by default unless you pass flag\n``--disable-private-mode`` at Splash startup. Note that if you disable\nprivate mode some of the browsing data may persist between requests\n(it doesn't affect cookies though).\n\nSee also: :ref:`disable-private-mode`.",
    "short": "Enable or disable browser's private mode (incognito mode).",
    "signature": "splash.private_mode_enabled = true/false",
    "returns": null,
    "async": null,
    "details": "Private mode is enabled by default unless you pass flag\n``--disable-private-mode`` at Splash startup. Note that if you disable\nprivate mode some of the browsing data may persist between requests\n(it doesn't affect cookies though).\n\nSee also: :ref:`disable-private-mode`.",
    "params": null
  },
  "splash.resource_timeout": {
    "name": null,
    "header": "splash.resource_timeout",
    "content": "Set a default timeout for network requests, in seconds.\n\n**Signature:** ``splash.resource_timeout = number``\n\nExample - abort requests to remote resources if they take more than 10 seconds:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash.resource_timeout = 10.0\n         assert(splash:go(splash.args.url))\n         return splash:png()\n     end\n\nZero or nil value means \"no timeout\".\n\nRequest timeouts set in :ref:`splash-on-request` using\n``request:set_timeout`` have a priority over :ref:`splash-resource-timeout`.",
    "short": "Set a default timeout for network requests, in seconds.",
    "signature": "splash.resource_timeout = number",
    "returns": null,
    "async": null,
    "details": "Example - abort requests to remote resources if they take more than 10 seconds:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash.resource_timeout = 10.0\n         assert(splash:go(splash.args.url))\n         return splash:png()\n     end\n\nZero or nil value means \"no timeout\".\n\nRequest timeouts set in :ref:`splash-on-request` using\n``request:set_timeout`` have a priority over :ref:`splash-resource-timeout`.",
    "params": null
  },
  "splash.images_enabled": {
    "name": null,
    "header": "splash.images_enabled",
    "content": "Enable/disable images.\n\n**Signature:** ``splash.images_enabled = true/false``\n\nBy default, images are enabled. Disabling of the images can save a lot\nof network traffic (usually around ~50%) and make rendering faster.\nNote that this option can affect the JavaScript code inside page:\ndisabling of the images may change sizes and positions of DOM elements,\nand scripts may read and use them.\n\nSplash uses in-memory cache; cached images will be displayed\neven when images are disabled. So if you load a page, then disable images,\nthen load a new page, then likely first page will display all images\nand second page will display some images (the ones common with the first page).\nSplash cache is shared between scripts executed in the same process, so you\ncan see some images even if they are disabled at the beginning of the script.\n\nExample:\n\nfunction main(splash, args)\n  splash.images_enabled = false\n  assert(splash:go(splash.args.url))\n  return {png=splash:png()}\nend",
    "short": "Enable/disable images.",
    "signature": "splash.images_enabled = true/false",
    "returns": null,
    "async": null,
    "details": "By default, images are enabled. Disabling of the images can save a lot\nof network traffic (usually around ~50%) and make rendering faster.\nNote that this option can affect the JavaScript code inside page:\ndisabling of the images may change sizes and positions of DOM elements,\nand scripts may read and use them.\n\nSplash uses in-memory cache; cached images will be displayed\neven when images are disabled. So if you load a page, then disable images,\nthen load a new page, then likely first page will display all images\nand second page will display some images (the ones common with the first page).\nSplash cache is shared between scripts executed in the same process, so you\ncan see some images even if they are disabled at the beginning of the script.\n\nExample:\n\nfunction main(splash, args)\n  splash.images_enabled = false\n  assert(splash:go(splash.args.url))\n  return {png=splash:png()}\nend",
    "params": null
  },
  "splash.plugins_enabled": {
    "name": null,
    "header": "splash.plugins_enabled",
    "content": "Enable or disable browser plugins (e.g. Flash).\n\n**Signature:** ``splash.plugins_enabled = true/false``\n\nPlugins are disabled by default.",
    "short": "Enable or disable browser plugins (e.g. Flash).",
    "signature": "splash.plugins_enabled = true/false",
    "returns": null,
    "async": null,
    "details": "Plugins are disabled by default.",
    "params": null
  },
  "splash.response_body_enabled": {
    "name": null,
    "header": "splash.response_body_enabled",
    "content": "Enable or disable response content tracking.\n\n**Signature:** ``splash.response_body_enabled = true/false``\n\nBy default Splash doesn't keep bodies of each response in memory,\nfor efficiency reasons. It means that in :ref:`splash-on-response`\ncallbacks :ref:`splash-response-body` attribute is not available, and that\nresponse content is not available in HAR_ exports. To make response content\navailable to a Lua script set ``splash.response_body_enabled = true``.\n\nNote that :ref:`splash-response-body` is always available\nin :ref:`splash-http-get` and :ref:`splash-http-post` results, regardless\nof :ref:`splash-response-body-enabled` option.\n\nTo enable response content tracking per-request call\n:ref:`splash-request-enable-response-body` in a :ref:`splash-on-request`\ncallback.",
    "short": "Enable or disable response content tracking.",
    "signature": "splash.response_body_enabled = true/false",
    "returns": null,
    "async": null,
    "details": "By default Splash doesn't keep bodies of each response in memory,\nfor efficiency reasons. It means that in :ref:`splash-on-response`\ncallbacks :ref:`splash-response-body` attribute is not available, and that\nresponse content is not available in HAR_ exports. To make response content\navailable to a Lua script set ``splash.response_body_enabled = true``.\n\nNote that :ref:`splash-response-body` is always available\nin :ref:`splash-http-get` and :ref:`splash-http-post` results, regardless\nof :ref:`splash-response-body-enabled` option.\n\nTo enable response content tracking per-request call\n:ref:`splash-request-enable-response-body` in a :ref:`splash-on-request`\ncallback.",
    "params": null
  },
  "splash.scroll_position": {
    "name": null,
    "header": "splash.scroll_position",
    "content": "Get or set current scroll position.\n\n**Signature:** ``splash.scroll_position = {x=..., y=...}``\n\nThis property allows to get and set current scroll position of the\nmain window.\n\nScrolling outside window content has no effect. For example, if you set\n``splash.scroll_position`` to ``{x=-100, y=-100}``, then\n``splash.scroll_position`` will likely still be equal to the default\n``{x=0, y=0}``.\n\nTo set scroll position instead of the full form\n(e.g. ``splash.scroll_position = {x=100, y=200}``) you can also use the\nshort form ``splash.scroll_position = {100, 200}``. Attribute\nvalue is always a table with ``x`` and ``y`` keys, even if you set it using\nthe short form.\n\nIt is also possible to omit coordinates which you don't want to change.\nFor example, ``splash.scroll_position = {y=200}`` sets y to 200 and keeps\nprevious x value.\n\n\nMethods\n~~~~~~~",
    "short": "Get or set current scroll position.",
    "signature": "splash.scroll_position = {x=..., y=...}",
    "returns": null,
    "async": null,
    "details": "This property allows to get and set current scroll position of the\nmain window.\n\nScrolling outside window content has no effect. For example, if you set\n``splash.scroll_position`` to ``{x=-100, y=-100}``, then\n``splash.scroll_position`` will likely still be equal to the default\n``{x=0, y=0}``.\n\nTo set scroll position instead of the full form\n(e.g. ``splash.scroll_position = {x=100, y=200}``) you can also use the\nshort form ``splash.scroll_position = {100, 200}``. Attribute\nvalue is always a table with ``x`` and ``y`` keys, even if you set it using\nthe short form.\n\nIt is also possible to omit coordinates which you don't want to change.\nFor example, ``splash.scroll_position = {y=200}`` sets y to 200 and keeps\nprevious x value.\n\n\nMethods\n~~~~~~~",
    "params": null
  },
  "splash:go": {
    "name": "go",
    "header": "splash:go",
    "content": "Go to an URL. This is similar to entering an URL in a browser\naddress bar, pressing Enter and waiting until page loads.\n\n**Signature:** ``ok, reason = splash:go{url, baseurl=nil, headers=nil, http_method=\"GET\", body=nil, formdata=nil}``\n\n**Parameters:**\n\n* url - URL to load;\n* baseurl - base URL to use, optional. When ``baseurl`` argument is passed\n  the page is still loaded from ``url``, but it is rendered as if it was\n  loaded from ``baseurl``: relative resource paths will be relative\n  to ``baseurl``, and the browser will think ``baseurl`` is in address bar;\n* headers - a Lua table with HTTP headers to add/replace in the initial request.\n* http_method - optional, string with HTTP method to use when visiting url,\n  defaults to GET, Splash also supports POST.\n* body - optional, string with body for POST request\n* formdata - Lua table that will be converted to urlencoded POST body and sent\n  with header ``content-type: application/x-www-form-urlencoded``\n\n**Returns:** ``ok, reason`` pair. If ``ok`` is nil then error happened during\npage load; ``reason`` provides an information about error type.\n\n**Async:** yes, unless the navigation is locked.\n\nFive types of errors are reported (``ok`` can be ``nil`` in 5 cases):\n\n1. There is a network error: a host doesn't exist, server dropped connection,\n   etc. In this case ``reason`` is ``\"network<code>\"``. A list of possible\n   error codes can be found in `Qt docs`_. For example, ``\"network3\"`` means\n   a DNS error (invalid hostname).\n2. Server returned a response with 4xx or 5xx HTTP status code.\n   ``reason`` is ``\"http<code>\"`` in this case, i.e. for\n   HTTP 404 Not Found ``reason`` is ``\"http404\"``.\n3. Navigation is locked (see :ref:`splash-lock-navigation`); ``reason``\n   is ``\"navigation_locked\"``.\n4. Splash can't render the main page (e.g. because the first request was\n   aborted) - ``reason`` is ``render_error``.\n5. If Splash can't decide what caused the error, just ``\"error\"`` is returned.\n\n.. _Qt docs: http://doc.qt.io/qt-5/qnetworkreply.html#NetworkError-enum\n\nError handling example:\n\n.. code-block:: lua\n\n    local ok, reason = splash:go(\"http://example.com\")\n    if not ok then\n        if reason:sub(0,4) == 'http' then\n            -- handle HTTP errors\n        else\n            -- handle other errors\n        end\n    end\n    -- process the page\n\n    -- assert can be used as a shortcut for error handling\n    assert(splash:go(\"http://example.com\"))\n\nErrors (ok==nil) are only reported when \"main\" webpage request failed.\nIf a request to a related resource failed then no error is reported by\n``splash:go``. To detect and handle such errors (e.g. broken image/js/css\nlinks, ajax requests failed to load) use :ref:`splash-har`\nor :ref:`splash-on-response`.\n\n``splash:go`` follows all HTTP redirects before returning the result,\nbut it doesn't follow HTML ``<meta http-equiv=\"refresh\" ...>`` redirects or\nredirects initiated by JavaScript code. To give the webpage time to follow\nthose redirects use :ref:`splash-wait`.\n\n``headers`` argument allows to add or replace default HTTP headers for the\ninitial request. To set custom headers for all further requests\n(including requests to related resources) use\n:ref:`splash-set-custom-headers` or :ref:`splash-on-request`.\n\nCustom headers example:\n\n.. code-block:: lua\n\n    local ok, reason = splash:go{\"http://example.com\", headers={\n        [\"Custom-Header\"] = \"Header Value\",\n    }})\n\nUser-Agent header is special: once used, it is kept for further requests.\nThis is an implementation detail and it could change in future releases;\nto set User-Agent header it is recommended to use\n:ref:`splash-set-user-agent` method.",
    "short": "Go to an URL. This is similar to entering an URL in a browser\naddress bar, pressing Enter and waiting until page loads.",
    "signature": "ok, reason = splash:go{url, baseurl=nil, headers=nil, http_method=\"GET\", body=nil, formdata=nil}",
    "returns": "``ok, reason`` pair. If ``ok`` is nil then error happened during\npage load; ``reason`` provides an information about error type.",
    "async": "yes, unless the navigation is locked.",
    "details": "Five types of errors are reported (``ok`` can be ``nil`` in 5 cases):\n\n1. There is a network error: a host doesn't exist, server dropped connection,\n   etc. In this case ``reason`` is ``\"network<code>\"``. A list of possible\n   error codes can be found in `Qt docs`_. For example, ``\"network3\"`` means\n   a DNS error (invalid hostname).\n2. Server returned a response with 4xx or 5xx HTTP status code.\n   ``reason`` is ``\"http<code>\"`` in this case, i.e. for\n   HTTP 404 Not Found ``reason`` is ``\"http404\"``.\n3. Navigation is locked (see :ref:`splash-lock-navigation`); ``reason``\n   is ``\"navigation_locked\"``.\n4. Splash can't render the main page (e.g. because the first request was\n   aborted) - ``reason`` is ``render_error``.\n5. If Splash can't decide what caused the error, just ``\"error\"`` is returned.\n\n.. _Qt docs: http://doc.qt.io/qt-5/qnetworkreply.html#NetworkError-enum\n\nError handling example:\n\n.. code-block:: lua\n\n    local ok, reason = splash:go(\"http://example.com\")\n    if not ok then\n        if reason:sub(0,4) == 'http' then\n            -- handle HTTP errors\n        else\n            -- handle other errors\n        end\n    end\n    -- process the page\n\n    -- assert can be used as a shortcut for error handling\n    assert(splash:go(\"http://example.com\"))\n\nErrors (ok==nil) are only reported when \"main\" webpage request failed.\nIf a request to a related resource failed then no error is reported by\n``splash:go``. To detect and handle such errors (e.g. broken image/js/css\nlinks, ajax requests failed to load) use :ref:`splash-har`\nor :ref:`splash-on-response`.\n\n``splash:go`` follows all HTTP redirects before returning the result,\nbut it doesn't follow HTML ``<meta http-equiv=\"refresh\" ...>`` redirects or\nredirects initiated by JavaScript code. To give the webpage time to follow\nthose redirects use :ref:`splash-wait`.\n\n``headers`` argument allows to add or replace default HTTP headers for the\ninitial request. To set custom headers for all further requests\n(including requests to related resources) use\n:ref:`splash-set-custom-headers` or :ref:`splash-on-request`.\n\nCustom headers example:\n\n.. code-block:: lua\n\n    local ok, reason = splash:go{\"http://example.com\", headers={\n        [\"Custom-Header\"] = \"Header Value\",\n    }})\n\nUser-Agent header is special: once used, it is kept for further requests.\nThis is an implementation detail and it could change in future releases;\nto set User-Agent header it is recommended to use\n:ref:`splash-set-user-agent` method.",
    "params": "* url - URL to load;\n* baseurl - base URL to use, optional. When ``baseurl`` argument is passed\n  the page is still loaded from ``url``, but it is rendered as if it was\n  loaded from ``baseurl``: relative resource paths will be relative\n  to ``baseurl``, and the browser will think ``baseurl`` is in address bar;\n* headers - a Lua table with HTTP headers to add/replace in the initial request.\n* http_method - optional, string with HTTP method to use when visiting url,\n  defaults to GET, Splash also supports POST.\n* body - optional, string with body for POST request\n* formdata - Lua table that will be converted to urlencoded POST body and sent\n  with header ``content-type: application/x-www-form-urlencoded``"
  },
  "splash:wait": {
    "name": "wait",
    "header": "splash:wait",
    "content": "Wait for ``time`` seconds. When script is waiting WebKit continues\nprocessing the webpage.\n\n**Signature:** ``ok, reason = splash:wait{time, cancel_on_redirect=false, cancel_on_error=true}``\n\n**Parameters:**\n\n* time - time to wait, in seconds;\n* cancel_on_redirect - if true (not a default) and a redirect\n  happened while waiting, then ``splash:wait`` stops earlier and returns\n  ``nil, \"redirect\"``. Redirect could be initiated by\n  ``<meta http-equiv=\"refresh\" ...>`` HTML tags or by JavaScript code.\n* cancel_on_error - if true (default) and an error which prevents page\n  from being rendered happened while waiting (e.g. an internal WebKit error\n  or a network error like a redirect to a non-resolvable host)\n  then ``splash:wait`` stops earlier and returns ``nil, \"<error string>\"``.\n\n**Returns:** ``ok, reason`` pair. If ``ok`` is ``nil`` then the timer was\nstopped prematurely, and ``reason`` contains a string with a reason.\n\n**Async:** yes.\n\nUsage example:\n\n.. code-block:: lua\n\n     -- go to example.com, wait 0.5s, return rendered html, ignore all errors.\n     function main(splash)\n         splash:go(\"http://example.com\")\n         splash:wait(0.5)\n         return {html=splash:html()}\n     end\n\nBy default wait timer continues to tick when redirect happens.\n``cancel_on_redirect`` option can be used to restart the timer after\neach redirect. For example, here is a function that waits for a given\ntime after each page load in case of redirects:\n\n.. code-block:: lua\n\n    function wait_restarting_on_redirects(splash, time, max_redirects)\n        local redirects_remaining = max_redirects\n        while redirects_remaining > 0 do\n            local ok, reason = self:wait{time=time, cancel_on_redirect=true}\n            if reason ~= 'redirect' then\n                return ok, reason\n            end\n            redirects_remaining = redirects_remaining - 1\n        end\n        return nil, \"too_many_redirects\"\n    end",
    "short": "Wait for ``time`` seconds. When script is waiting WebKit continues\nprocessing the webpage.",
    "signature": "ok, reason = splash:wait{time, cancel_on_redirect=false, cancel_on_error=true}",
    "returns": "``ok, reason`` pair. If ``ok`` is ``nil`` then the timer was\nstopped prematurely, and ``reason`` contains a string with a reason.",
    "async": "yes.",
    "details": "Usage example:\n\n.. code-block:: lua\n\n     -- go to example.com, wait 0.5s, return rendered html, ignore all errors.\n     function main(splash)\n         splash:go(\"http://example.com\")\n         splash:wait(0.5)\n         return {html=splash:html()}\n     end\n\nBy default wait timer continues to tick when redirect happens.\n``cancel_on_redirect`` option can be used to restart the timer after\neach redirect. For example, here is a function that waits for a given\ntime after each page load in case of redirects:\n\n.. code-block:: lua\n\n    function wait_restarting_on_redirects(splash, time, max_redirects)\n        local redirects_remaining = max_redirects\n        while redirects_remaining > 0 do\n            local ok, reason = self:wait{time=time, cancel_on_redirect=true}\n            if reason ~= 'redirect' then\n                return ok, reason\n            end\n            redirects_remaining = redirects_remaining - 1\n        end\n        return nil, \"too_many_redirects\"\n    end",
    "params": "* time - time to wait, in seconds;\n* cancel_on_redirect - if true (not a default) and a redirect\n  happened while waiting, then ``splash:wait`` stops earlier and returns\n  ``nil, \"redirect\"``. Redirect could be initiated by\n  ``<meta http-equiv=\"refresh\" ...>`` HTML tags or by JavaScript code.\n* cancel_on_error - if true (default) and an error which prevents page\n  from being rendered happened while waiting (e.g. an internal WebKit error\n  or a network error like a redirect to a non-resolvable host)\n  then ``splash:wait`` stops earlier and returns ``nil, \"<error string>\"``."
  },
  "splash:jsfunc": {
    "name": "jsfunc",
    "header": "splash:jsfunc",
    "content": "Convert JavaScript function to a Lua callable.\n\n**Signature:** ``lua_func = splash:jsfunc(func)``\n\n**Parameters:**\n\n* func - a string which defines a JavaScript function.\n\n**Returns:** a function that can be called from Lua to execute JavaScript\ncode in page context.\n\n**Async:** no.\n\nExample:\n\nfunction main(splash, args)\n  local get_div_count = splash:jsfunc([[\n  function () {\n    var body = document.body;\n    var divs = body.getElementsByTagName('div');\n    return divs.length;\n  }\n  ]])\n  splash:go(args.url)\n\n  return (\"There are %s DIVs in %s\"):format(\n    get_div_count(), args.url)\nend\nNote how Lua ``[[ ]]`` string syntax is helpful here.\n\nJavaScript functions may accept arguments:\n\n.. code-block:: lua\n\n    local vec_len = splash:jsfunc([[\n        function(x, y) {\n           return Math.sqrt(x*x + y*y)\n        }\n    ]])\n    return {res=vec_len(5, 4)}\n\nGlobal JavaScript functions can be wrapped directly:\n\n.. code-block:: lua\n\n    local pow = splash:jsfunc(\"Math.pow\")\n    local twenty_five = pow(5, 2)  -- 5^2 is 25\n    local thousand = pow(10, 3)    -- 10^3 is 1000\n\n.. _lua-js-conversion-rules:\n\nLua \u2192 JavaScript conversion rules:\n\n==============  ==========================\nLua             JavaScript\n==============  ==========================\nstring          string\nnumber          number\nboolean         boolean\ntable           Object or Array, see below\nnil             undefined\nElement         DOM node\n==============  ==========================\n\nLua strings, numbers, booleans and tables can be passed as arguments;\nthey are converted to JS strings/numbers/booleans/objects.\n:ref:`Element <splash-element>` instances are supported, but they can't\nbe inside a Lua table.\n\nCurrently it is not possible to pass other Lua objects. For example, it\nis not possible to pass a wrapped JavaScript function or a regular Lua function\nas an argument to another wrapped JavaScript function.\n\nBy default Lua tables are converted to JavaScript Objects. To convert\na table to an Array use :ref:`treat-as-array`.\n\n.. _js-lua-conversion-rules:\n\nJavaScript \u2192 Lua conversion rules:\n\n================  =================\nJavaScript        Lua\n================  =================\nstring            string\nnumber            number\nboolean           boolean\nObject            table\nArray             table, marked as array (see :ref:`treat-as-array`)\n``undefined``     ``nil``\n``null``          ``\"\"`` (an empty string)\nDate              string: date's ISO8601 representation, e.g.\n                  ``1958-05-21T10:12:00.000Z``\nNode              :ref:`Element <splash-element>` instance\nNodeList          a tabl with :ref:`Element <splash-element>` instances\nfunction          ``nil``\ncircular object   ``nil``\nhost object       ``nil``\n================  =================\n\nFunction result is converted from JavaScript to Lua data type. Only simple\nJS objects are supported. For example, returning a function or a\nJQuery selector from a wrapped function won't work.\n\nReturning a Node (a reference to a DOM element) or NodeList instance\n(result of document.querySelectorAll) works though, but only if Node\nor NodeList is the only result - Nodes and NodeLists can't be inside\nother objects or arrays.\n\n.. note::\n\n    The rule of thumb: if an argument or a return value can be serialized\n    via JSON, then it is fine. You can also return DOM Element or a NodeList,\n    but they can't be inside other data structures.\n\nNote that currently you can't return JQuery $ results and\nsimilar structures from JavaScript to Lua; to pass data you have to\nextract their attributes of interest as plain strings/numbers/objects/arrays:\n\n.. code-block:: lua\n\n    -- this function assumes jQuery is loaded in page\n    local get_hrefs = splash:jsfunc([[\n        function(sel){\n            return $(sel).map(function(){return this.href}).get();\n        }\n    ]])\n    local hrefs = get_hrefs(\"a.story-title\")\n\nHowever, you can also write the code above using\n:ref:`Element <splash-element>` objects and :ref:`splash-select-all`:\n\n.. code-block:: lua\n\n    local elems = splash:select_all(\"a.story-title\")\n    local hrefs = {}\n    for i, elem in ipairs(elems) do\n        hrefs[i] = elem.node:getAttribute(\"href\")\n    end\n\nFunction arguments and return values are passed by value. For example,\nif you modify an argument from inside a JavaScript function then the caller\nLua code won't see the changes, and if you return a global JS object and modify\nit in Lua then object won't be changed in webpage context. The exception is\n:ref:`Element <splash-element>` which has some mutable fields.\n\nIf a JavaScript function throws an error, it is re-throwed as a Lua error.\nTo handle errors it is better to use JavaScript try/catch because some of the\ninformation about the error can be lost in JavaScript \u2192 Lua conversion.\n\nSee also: :ref:`splash-runjs`, :ref:`splash-evaljs`, :ref:`splash-wait-for-resume`,\n:ref:`splash-autoload`, :ref:`treat-as-array`, :ref:`splash-element`,\n:ref:`splash-select`, :ref:`splash-select-all`.",
    "short": "Convert JavaScript function to a Lua callable.",
    "signature": "lua_func = splash:jsfunc(func)",
    "returns": "a function that can be called from Lua to execute JavaScript\ncode in page context.",
    "async": "no.",
    "details": "Example:\n\nfunction main(splash, args)\n  local get_div_count = splash:jsfunc([[\n  function () {\n    var body = document.body;\n    var divs = body.getElementsByTagName('div');\n    return divs.length;\n  }\n  ]])\n  splash:go(args.url)\n\n  return (\"There are %s DIVs in %s\"):format(\n    get_div_count(), args.url)\nend\nNote how Lua ``[[ ]]`` string syntax is helpful here.\n\nJavaScript functions may accept arguments:\n\n.. code-block:: lua\n\n    local vec_len = splash:jsfunc([[\n        function(x, y) {\n           return Math.sqrt(x*x + y*y)\n        }\n    ]])\n    return {res=vec_len(5, 4)}\n\nGlobal JavaScript functions can be wrapped directly:\n\n.. code-block:: lua\n\n    local pow = splash:jsfunc(\"Math.pow\")\n    local twenty_five = pow(5, 2)  -- 5^2 is 25\n    local thousand = pow(10, 3)    -- 10^3 is 1000\n\n.. _lua-js-conversion-rules:\n\nLua \u2192 JavaScript conversion rules:\n\n==============  ==========================\nLua             JavaScript\n==============  ==========================\nstring          string\nnumber          number\nboolean         boolean\ntable           Object or Array, see below\nnil             undefined\nElement         DOM node\n==============  ==========================\n\nLua strings, numbers, booleans and tables can be passed as arguments;\nthey are converted to JS strings/numbers/booleans/objects.\n:ref:`Element <splash-element>` instances are supported, but they can't\nbe inside a Lua table.\n\nCurrently it is not possible to pass other Lua objects. For example, it\nis not possible to pass a wrapped JavaScript function or a regular Lua function\nas an argument to another wrapped JavaScript function.\n\nBy default Lua tables are converted to JavaScript Objects. To convert\na table to an Array use :ref:`treat-as-array`.\n\n.. _js-lua-conversion-rules:\n\nJavaScript \u2192 Lua conversion rules:\n\n================  =================\nJavaScript        Lua\n================  =================\nstring            string\nnumber            number\nboolean           boolean\nObject            table\nArray             table, marked as array (see :ref:`treat-as-array`)\n``undefined``     ``nil``\n``null``          ``\"\"`` (an empty string)\nDate              string: date's ISO8601 representation, e.g.\n                  ``1958-05-21T10:12:00.000Z``\nNode              :ref:`Element <splash-element>` instance\nNodeList          a tabl with :ref:`Element <splash-element>` instances\nfunction          ``nil``\ncircular object   ``nil``\nhost object       ``nil``\n================  =================\n\nFunction result is converted from JavaScript to Lua data type. Only simple\nJS objects are supported. For example, returning a function or a\nJQuery selector from a wrapped function won't work.\n\nReturning a Node (a reference to a DOM element) or NodeList instance\n(result of document.querySelectorAll) works though, but only if Node\nor NodeList is the only result - Nodes and NodeLists can't be inside\nother objects or arrays.\n\n.. note::\n\n    The rule of thumb: if an argument or a return value can be serialized\n    via JSON, then it is fine. You can also return DOM Element or a NodeList,\n    but they can't be inside other data structures.\n\nNote that currently you can't return JQuery $ results and\nsimilar structures from JavaScript to Lua; to pass data you have to\nextract their attributes of interest as plain strings/numbers/objects/arrays:\n\n.. code-block:: lua\n\n    -- this function assumes jQuery is loaded in page\n    local get_hrefs = splash:jsfunc([[\n        function(sel){\n            return $(sel).map(function(){return this.href}).get();\n        }\n    ]])\n    local hrefs = get_hrefs(\"a.story-title\")\n\nHowever, you can also write the code above using\n:ref:`Element <splash-element>` objects and :ref:`splash-select-all`:\n\n.. code-block:: lua\n\n    local elems = splash:select_all(\"a.story-title\")\n    local hrefs = {}\n    for i, elem in ipairs(elems) do\n        hrefs[i] = elem.node:getAttribute(\"href\")\n    end\n\nFunction arguments and return values are passed by value. For example,\nif you modify an argument from inside a JavaScript function then the caller\nLua code won't see the changes, and if you return a global JS object and modify\nit in Lua then object won't be changed in webpage context. The exception is\n:ref:`Element <splash-element>` which has some mutable fields.\n\nIf a JavaScript function throws an error, it is re-throwed as a Lua error.\nTo handle errors it is better to use JavaScript try/catch because some of the\ninformation about the error can be lost in JavaScript \u2192 Lua conversion.\n\nSee also: :ref:`splash-runjs`, :ref:`splash-evaljs`, :ref:`splash-wait-for-resume`,\n:ref:`splash-autoload`, :ref:`treat-as-array`, :ref:`splash-element`,\n:ref:`splash-select`, :ref:`splash-select-all`.",
    "params": "* func - a string which defines a JavaScript function."
  },
  "splash:evaljs": {
    "name": "evaljs",
    "header": "splash:evaljs",
    "content": "Execute a JavaScript snippet in page context and return the result of the\nlast statement.\n\n**Signature:** ``result = splash:evaljs(snippet)``\n\n**Parameters:**\n\n* snippet - a string with JavaScript source code to execute.\n\n**Returns:** the result of the last statement in ``snippet``,\nconverted from JavaScript to Lua data types. In case of syntax errors or\nJavaScript exceptions an error is raised.\n\n**Async:** no.\n\nJavaScript \u2192 Lua conversion rules are the same as for\n:ref:`splash:jsfunc <js-lua-conversion-rules>`.\n\n``splash:evaljs`` is useful for evaluation of short JavaScript snippets\nwithout defining a wrapper function. Example:\n\n.. code-block:: lua\n\n    local title = splash:evaljs(\"document.title\")\n\nDon't use :ref:`splash-evaljs` when the result is not needed - it is\ninefficient and could lead to problems; use :ref:`splash-runjs` instead.\nFor example, the following innocent-looking code (using jQuery) will do\nunnecessary work:\n\n.. code-block:: lua\n\n    splash:evaljs(\"$(console.log('foo'));\")\n\nA gotcha is that to allow chaining jQuery ``$`` function returns a huge object,\n:ref:`splash-evaljs` tries to serialize it and convert to Lua,\nwhich is a waste of resources. :ref:`splash-runjs` doesn't have this problem.\n\nIf the code you're evaluating needs arguments it is better to use\n:ref:`splash-jsfunc` instead of :ref:`splash-evaljs` and string formatting.\nCompare:\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local font_size = splash:jsfunc([[\n            function(sel) {\n                var el = document.querySelector(sel);\n                return getComputedStyle(el)[\"font-size\"];\n            }\n        ]])\n\n        local font_size2 = function(sel)\n            -- FIXME: escaping of `sel` parameter!\n            local js = string.format([[\n                var el = document.querySelector(\"%s\");\n                getComputedStyle(el)[\"font-size\"]\n            ]], sel)\n            return splash:evaljs(js)\n        end\n\n        -- ...\n    end\n\nSee also: :ref:`splash-runjs`, :ref:`splash-jsfunc`,\n:ref:`splash-wait-for-resume`, :ref:`splash-autoload`,\n:ref:`splash-element`, :ref:`splash-select`, :ref:`splash-select-all`.",
    "short": "Execute a JavaScript snippet in page context and return the result of the\nlast statement.",
    "signature": "result = splash:evaljs(snippet)",
    "returns": "the result of the last statement in ``snippet``,\nconverted from JavaScript to Lua data types. In case of syntax errors or\nJavaScript exceptions an error is raised.",
    "async": "no.",
    "details": "JavaScript \u2192 Lua conversion rules are the same as for\n:ref:`splash:jsfunc <js-lua-conversion-rules>`.\n\n``splash:evaljs`` is useful for evaluation of short JavaScript snippets\nwithout defining a wrapper function. Example:\n\n.. code-block:: lua\n\n    local title = splash:evaljs(\"document.title\")\n\nDon't use :ref:`splash-evaljs` when the result is not needed - it is\ninefficient and could lead to problems; use :ref:`splash-runjs` instead.\nFor example, the following innocent-looking code (using jQuery) will do\nunnecessary work:\n\n.. code-block:: lua\n\n    splash:evaljs(\"$(console.log('foo'));\")\n\nA gotcha is that to allow chaining jQuery ``$`` function returns a huge object,\n:ref:`splash-evaljs` tries to serialize it and convert to Lua,\nwhich is a waste of resources. :ref:`splash-runjs` doesn't have this problem.\n\nIf the code you're evaluating needs arguments it is better to use\n:ref:`splash-jsfunc` instead of :ref:`splash-evaljs` and string formatting.\nCompare:\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local font_size = splash:jsfunc([[\n            function(sel) {\n                var el = document.querySelector(sel);\n                return getComputedStyle(el)[\"font-size\"];\n            }\n        ]])\n\n        local font_size2 = function(sel)\n            -- FIXME: escaping of `sel` parameter!\n            local js = string.format([[\n                var el = document.querySelector(\"%s\");\n                getComputedStyle(el)[\"font-size\"]\n            ]], sel)\n            return splash:evaljs(js)\n        end\n\n        -- ...\n    end\n\nSee also: :ref:`splash-runjs`, :ref:`splash-jsfunc`,\n:ref:`splash-wait-for-resume`, :ref:`splash-autoload`,\n:ref:`splash-element`, :ref:`splash-select`, :ref:`splash-select-all`.",
    "params": "* snippet - a string with JavaScript source code to execute."
  },
  "splash:runjs": {
    "name": "runjs",
    "header": "splash:runjs",
    "content": "Run JavaScript code in page context.\n\n**Signature:** ``ok, error = splash:runjs(snippet)``\n\n**Parameters:**\n\n* snippet - a string with JavaScript source code to execute.\n\n**Returns:** ``ok, error`` pair. When the execution is successful\n``ok`` is True. In case of JavaScript errors ``ok`` is ``nil``,\nand ``error`` contains the error string.\n\n**Async:** no.\n\nExample:\n\n.. code-block:: lua\n\n    assert(splash:runjs(\"document.title = 'hello';\"))\n\nNote that JavaScript functions defined using ``function foo(){}`` syntax\n**won't** be added to the global scope:\n\n.. code-block:: lua\n\n    assert(splash:runjs(\"function foo(){return 'bar'}\"))\n    local res = splash:evaljs(\"foo()\")  -- this raises an error\n\nIt is an implementation detail: the code passed to :ref:`splash-runjs`\nis executed in a closure. To define functions use global variables, e.g.:\n\n.. code-block:: lua\n\n    assert(splash:runjs(\"foo = function (){return 'bar'}\"))\n    local res = splash:evaljs(\"foo()\")  -- this returns 'bar'\n\nIf the code needs arguments it is better to use :ref:`splash-jsfunc`.\nCompare:\n\n.. code-block:: lua\n\n    function main(splash)\n\n        -- Lua function to scroll window to (x, y) position.\n        function scroll_to(x, y)\n            local js = string.format(\n                \"window.scrollTo(%s, %s);\",\n                tonumber(x),\n                tonumber(y)\n            )\n            assert(splash:runjs(js))\n        end\n\n        -- a simpler version using splash:jsfunc\n        local scroll_to2 = splash:jsfunc(\"window.scrollTo\")\n\n        -- ...\n    end\n\nSee also: :ref:`splash-runjs`, :ref:`splash-jsfunc`, :ref:`splash-autoload`,\n:ref:`splash-wait-for-resume`.",
    "short": "Run JavaScript code in page context.",
    "signature": "ok, error = splash:runjs(snippet)",
    "returns": "``ok, error`` pair. When the execution is successful\n``ok`` is True. In case of JavaScript errors ``ok`` is ``nil``,\nand ``error`` contains the error string.",
    "async": "no.",
    "details": "Example:\n\n.. code-block:: lua\n\n    assert(splash:runjs(\"document.title = 'hello';\"))\n\nNote that JavaScript functions defined using ``function foo(){}`` syntax\n**won't** be added to the global scope:\n\n.. code-block:: lua\n\n    assert(splash:runjs(\"function foo(){return 'bar'}\"))\n    local res = splash:evaljs(\"foo()\")  -- this raises an error\n\nIt is an implementation detail: the code passed to :ref:`splash-runjs`\nis executed in a closure. To define functions use global variables, e.g.:\n\n.. code-block:: lua\n\n    assert(splash:runjs(\"foo = function (){return 'bar'}\"))\n    local res = splash:evaljs(\"foo()\")  -- this returns 'bar'\n\nIf the code needs arguments it is better to use :ref:`splash-jsfunc`.\nCompare:\n\n.. code-block:: lua\n\n    function main(splash)\n\n        -- Lua function to scroll window to (x, y) position.\n        function scroll_to(x, y)\n            local js = string.format(\n                \"window.scrollTo(%s, %s);\",\n                tonumber(x),\n                tonumber(y)\n            )\n            assert(splash:runjs(js))\n        end\n\n        -- a simpler version using splash:jsfunc\n        local scroll_to2 = splash:jsfunc(\"window.scrollTo\")\n\n        -- ...\n    end\n\nSee also: :ref:`splash-runjs`, :ref:`splash-jsfunc`, :ref:`splash-autoload`,\n:ref:`splash-wait-for-resume`.",
    "params": "* snippet - a string with JavaScript source code to execute."
  },
  "splash:wait_for_resume": {
    "name": "wait_for_resume",
    "header": "splash:wait_for_resume",
    "content": "Run asynchronous JavaScript code in page context. The Lua script will\nyield until the JavaScript code tells it to resume.\n\n**Signature:** ``result, error = splash:wait_for_resume(snippet, timeout)``\n\n**Parameters:**\n\n* snippet - a string with a JavaScript source code to execute. This code\n  must include a function called ``main``. The first argument to ``main``\n  is an object that has the properties ``resume`` and ``error``. ``resume``\n  is a function which can be used to resume Lua execution. It takes an optional\n  argument which will be returned to Lua in the ``result.value`` return value.\n  ``error`` is a function which can be called with a required string value\n  that is returned in the ``error`` return value.\n* timeout - a number which determines (in seconds) how long to allow JavaScript\n  to execute before forceably returning control to Lua. Defaults to\n  zero, which disables the timeout.\n\n**Returns:** ``result, error`` pair. When the execution is successful\n``result`` is a table. If the value returned by JavaScript is not\n``undefined``, then the ``result`` table will contain a key ``value``\nthat has the value passed to ``splash.resume(\u2026)``. The ``result`` table also\ncontains any additional key/value pairs set by ``splash.set(\u2026)``. In case of\ntimeout or JavaScript errors ``result`` is ``nil`` and ``error`` contains an\nerror message string.\n\n**Async:** yes.\n\nExamples:\n\nThe first, trivial example shows how to transfer control of execution from Lua\nto JavaScript and then back to Lua. This command will tell JavaScript to\nsleep for 3 seconds and then return to Lua. Note that this is an async\noperation: the Lua event loop and the JavaScript event loop continue to run\nduring this 3 second pause, but Lua will not continue executing the current\nfunction until JavaScript calls ``splash.resume()``.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume();\n                }, 3000);\n            }\n        ]])\n\n        -- result is {}\n        -- error is nil\n\n    end\n\n``result`` is set to an empty table to indicate that nothing was returned\nfrom ``splash.resume``. You can use ``assert(splash:wait_for_resume(\u2026))``\neven when JavaScript does not return a value because the empty table signifies\nsuccess to ``assert()``.\n\n.. note::\n\n    Your JavaScript code must contain a ``main()`` function. You will get an\n    error if you do not include it. The first argument to this function can\n    have any name you choose, of course. We will call it ``splash`` by\n    convention in this documentation.\n\nThe next example shows how to return a value from JavaScript to Lua.\nYou can return booleans, numbers, strings, arrays, or objects.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume([1, 2, 'red', 'blue']);\n                }, 3000);\n            }\n        ]])\n\n        -- result is {value={1, 2, 'red', 'blue'}}\n        -- error is nil\n\n    end\n\n.. note::\n\n    As with :ref:`splash-evaljs`, be wary of returning objects that are\n    too large, such as the ``$`` object in jQuery, which will consume a lot\n    of time and memory to convert to a Lua result.\n\nYou can also set additional key/value pairs in JavaScript with the\n``splash.set(key, value)`` function. Key/value pairs will be included\nin the ``result`` table returned to Lua. The following example demonstrates\nthis.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.set(\"foo\", \"bar\");\n                    splash.resume(\"ok\");\n                }, 3000);\n            }\n        ]])\n\n        -- result is {foo=\"bar\", value=\"ok\"}\n        -- error is nil\n\n    end\n\nThe next example shows an incorrect usage of ``splash:wait_for_resume()``:\nthe JavaScript code does not contain a ``main()`` function. ``result`` is\nnil because ``splash.resume()`` is never called, and ``error`` contains\nan error message explaining the mistake.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            console.log('hello!');\n        ]])\n\n        -- result is nil\n        -- error is \"error: wait_for_resume(): no main() function defined\"\n\n    end\n\nThe next example shows error handling. If ``splash.error(\u2026)`` is\ncalled instead of ``splash.resume()``, then ``result`` will be ``nil``\nand ``error`` will contain the string passed to ``splash.error(\u2026)``.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.error(\"Goodbye, cruel world!\");\n                }, 3000);\n            }\n        ]])\n\n        -- result is nil\n        -- error is \"error: Goodbye, cruel world!\"\n\n    end\n\nYour JavaScript code must either call ``splash.resume()`` or\n``splash.error()`` exactly one time. Subsequent calls to either function\nhave no effect, as shown in the next example.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume(\"ok\");\n                    splash.resume(\"still ok\");\n                    splash.error(\"not ok\");\n                }, 3000);\n            }\n        ]])\n\n        -- result is {value=\"ok\"}\n        -- error is nil\n\n    end\n\nThe next example shows the effect of the ``timeout`` argument. We have set\nthe ``timeout`` argument to 1 second, but our JavaScript code will not call\n``splash.resume()`` for 3 seconds, which guarantees that\n``splash:wait_for_resume()`` will time out.\n\nWhen it times out, ``result`` will be nil, ``error`` will contain a string\nexplaining the timeout, and Lua will continue executing. Calling\n``splash.resume()`` or ``splash.error()`` after a timeout has no effect.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume(\"Hello, world!\");\n                }, 3000);\n            }\n        ]], 1)\n\n        -- result is nil\n        -- error is \"error: One shot callback timed out while waiting for resume() or error().\"\n\n    end\n\n.. note::\n\n    The timeout must be >= 0. If the timeout is 0, then\n    ``splash:wait_for_resume()`` will never timeout (although Splash's\n    HTTP timeout still applies).\n\nNote that your JavaScript code is not forceably canceled by a timeout: it may\ncontinue to run until Splash shuts down the entire browser context.\n\nSee also: :ref:`splash-runjs`, :ref:`splash-jsfunc`, :ref:`splash-evaljs`.",
    "short": "Run asynchronous JavaScript code in page context. The Lua script will\nyield until the JavaScript code tells it to resume.",
    "signature": "result, error = splash:wait_for_resume(snippet, timeout)",
    "returns": "``result, error`` pair. When the execution is successful\n``result`` is a table. If the value returned by JavaScript is not\n``undefined``, then the ``result`` table will contain a key ``value``\nthat has the value passed to ``splash.resume(\u2026)``. The ``result`` table also\ncontains any additional key/value pairs set by ``splash.set(\u2026)``. In case of\ntimeout or JavaScript errors ``result`` is ``nil`` and ``error`` contains an\nerror message string.",
    "async": "yes.",
    "details": "Examples:\n\nThe first, trivial example shows how to transfer control of execution from Lua\nto JavaScript and then back to Lua. This command will tell JavaScript to\nsleep for 3 seconds and then return to Lua. Note that this is an async\noperation: the Lua event loop and the JavaScript event loop continue to run\nduring this 3 second pause, but Lua will not continue executing the current\nfunction until JavaScript calls ``splash.resume()``.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume();\n                }, 3000);\n            }\n        ]])\n\n        -- result is {}\n        -- error is nil\n\n    end\n\n``result`` is set to an empty table to indicate that nothing was returned\nfrom ``splash.resume``. You can use ``assert(splash:wait_for_resume(\u2026))``\neven when JavaScript does not return a value because the empty table signifies\nsuccess to ``assert()``.\n\n.. note::\n\n    Your JavaScript code must contain a ``main()`` function. You will get an\n    error if you do not include it. The first argument to this function can\n    have any name you choose, of course. We will call it ``splash`` by\n    convention in this documentation.\n\nThe next example shows how to return a value from JavaScript to Lua.\nYou can return booleans, numbers, strings, arrays, or objects.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume([1, 2, 'red', 'blue']);\n                }, 3000);\n            }\n        ]])\n\n        -- result is {value={1, 2, 'red', 'blue'}}\n        -- error is nil\n\n    end\n\n.. note::\n\n    As with :ref:`splash-evaljs`, be wary of returning objects that are\n    too large, such as the ``$`` object in jQuery, which will consume a lot\n    of time and memory to convert to a Lua result.\n\nYou can also set additional key/value pairs in JavaScript with the\n``splash.set(key, value)`` function. Key/value pairs will be included\nin the ``result`` table returned to Lua. The following example demonstrates\nthis.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.set(\"foo\", \"bar\");\n                    splash.resume(\"ok\");\n                }, 3000);\n            }\n        ]])\n\n        -- result is {foo=\"bar\", value=\"ok\"}\n        -- error is nil\n\n    end\n\nThe next example shows an incorrect usage of ``splash:wait_for_resume()``:\nthe JavaScript code does not contain a ``main()`` function. ``result`` is\nnil because ``splash.resume()`` is never called, and ``error`` contains\nan error message explaining the mistake.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            console.log('hello!');\n        ]])\n\n        -- result is nil\n        -- error is \"error: wait_for_resume(): no main() function defined\"\n\n    end\n\nThe next example shows error handling. If ``splash.error(\u2026)`` is\ncalled instead of ``splash.resume()``, then ``result`` will be ``nil``\nand ``error`` will contain the string passed to ``splash.error(\u2026)``.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.error(\"Goodbye, cruel world!\");\n                }, 3000);\n            }\n        ]])\n\n        -- result is nil\n        -- error is \"error: Goodbye, cruel world!\"\n\n    end\n\nYour JavaScript code must either call ``splash.resume()`` or\n``splash.error()`` exactly one time. Subsequent calls to either function\nhave no effect, as shown in the next example.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume(\"ok\");\n                    splash.resume(\"still ok\");\n                    splash.error(\"not ok\");\n                }, 3000);\n            }\n        ]])\n\n        -- result is {value=\"ok\"}\n        -- error is nil\n\n    end\n\nThe next example shows the effect of the ``timeout`` argument. We have set\nthe ``timeout`` argument to 1 second, but our JavaScript code will not call\n``splash.resume()`` for 3 seconds, which guarantees that\n``splash:wait_for_resume()`` will time out.\n\nWhen it times out, ``result`` will be nil, ``error`` will contain a string\nexplaining the timeout, and Lua will continue executing. Calling\n``splash.resume()`` or ``splash.error()`` after a timeout has no effect.\n\n.. code-block:: lua\n\n    function main(splash)\n\n        local result, error = splash:wait_for_resume([[\n            function main(splash) {\n                setTimeout(function () {\n                    splash.resume(\"Hello, world!\");\n                }, 3000);\n            }\n        ]], 1)\n\n        -- result is nil\n        -- error is \"error: One shot callback timed out while waiting for resume() or error().\"\n\n    end\n\n.. note::\n\n    The timeout must be >= 0. If the timeout is 0, then\n    ``splash:wait_for_resume()`` will never timeout (although Splash's\n    HTTP timeout still applies).\n\nNote that your JavaScript code is not forceably canceled by a timeout: it may\ncontinue to run until Splash shuts down the entire browser context.\n\nSee also: :ref:`splash-runjs`, :ref:`splash-jsfunc`, :ref:`splash-evaljs`.",
    "params": "* snippet - a string with a JavaScript source code to execute. This code\n  must include a function called ``main``. The first argument to ``main``\n  is an object that has the properties ``resume`` and ``error``. ``resume``\n  is a function which can be used to resume Lua execution. It takes an optional\n  argument which will be returned to Lua in the ``result.value`` return value.\n  ``error`` is a function which can be called with a required string value\n  that is returned in the ``error`` return value.\n* timeout - a number which determines (in seconds) how long to allow JavaScript\n  to execute before forceably returning control to Lua. Defaults to\n  zero, which disables the timeout."
  },
  "splash:autoload": {
    "name": "autoload",
    "header": "splash:autoload",
    "content": "Set JavaScript to load automatically on each page load.\n\n**Signature:** ``ok, reason = splash:autoload{source_or_url, source=nil, url=nil}``\n\n**Parameters:**\n\n* source_or_url - either a string with JavaScript source code or an URL\n  to load the JavaScript code from;\n* source - a string with JavaScript source code;\n* url - an URL to load JavaScript source code from.\n\n**Returns:** ``ok, reason`` pair. If ``ok`` is nil, error happened and\n``reason`` contains an error description.\n\n**Async:** yes, but only when an URL of a remote resource is passed.\n\n:ref:`splash-autoload` allows to execute JavaScript code at each page load.\n:ref:`splash-autoload` doesn't doesn't execute the passed\nJavaScript code itself. To execute some code once, *after* page is loaded\nuse :ref:`splash-runjs` or :ref:`splash-jsfunc`.\n\n:ref:`splash-autoload` can be used to preload utility JavaScript libraries\nor replace JavaScript objects before a webpage has a chance to do it.\n\nExample:\n\nfunction main(splash, args)\n  splash:autoload([[\n    function get_document_title(){\n      return document.title;\n    }\n  ]])\n  assert(splash:go(args.url))\n\n  return splash:evaljs(\"get_document_title()\")\nend\nFor the convenience, when a first :ref:`splash-autoload` argument starts\nwith \"http://\" or \"https://\" a script from the passed URL is loaded.\nExample 2 - make sure a remote library is available:\n\nfunction main(splash, args)\n  assert(splash:autoload(\"https://code.jquery.com/jquery-2.1.3.min.js\"))\n  assert(splash:go(splash.args.url))\n  local version = splash:evaljs(\"$.fn.jquery\")\n\n  return 'JQuery version: ' .. version\nend\n\nTo disable URL auto-detection use 'source' and 'url' arguments:\n\n.. code-block:: lua\n\n    splash:autoload{url=\"https://code.jquery.com/jquery-2.1.3.min.js\"}\n    splash:autoload{source=\"window.foo = 'bar';\"}\n\nIt is a good practice not to rely on auto-detection when the argument\nis not a constant.\n\nIf :ref:`splash-autoload` is called multiple times then all its scripts\nare executed on page load, in order they were added.\n\nTo revert Splash not to execute anything on page load use\n:ref:`splash-autoload-reset`.\n\nSee also: :ref:`splash-evaljs`, :ref:`splash-runjs`, :ref:`splash-jsfunc`,\n:ref:`splash-wait-for-resume`, :ref:`splash-autoload-reset`.",
    "short": "Set JavaScript to load automatically on each page load.",
    "signature": "ok, reason = splash:autoload{source_or_url, source=nil, url=nil}",
    "returns": "``ok, reason`` pair. If ``ok`` is nil, error happened and\n``reason`` contains an error description.",
    "async": "yes, but only when an URL of a remote resource is passed.",
    "details": ":ref:`splash-autoload` allows to execute JavaScript code at each page load.\n:ref:`splash-autoload` doesn't doesn't execute the passed\nJavaScript code itself. To execute some code once, *after* page is loaded\nuse :ref:`splash-runjs` or :ref:`splash-jsfunc`.\n\n:ref:`splash-autoload` can be used to preload utility JavaScript libraries\nor replace JavaScript objects before a webpage has a chance to do it.\n\nExample:\n\nfunction main(splash, args)\n  splash:autoload([[\n    function get_document_title(){\n      return document.title;\n    }\n  ]])\n  assert(splash:go(args.url))\n\n  return splash:evaljs(\"get_document_title()\")\nend\nFor the convenience, when a first :ref:`splash-autoload` argument starts\nwith \"http://\" or \"https://\" a script from the passed URL is loaded.\nExample 2 - make sure a remote library is available:\n\nfunction main(splash, args)\n  assert(splash:autoload(\"https://code.jquery.com/jquery-2.1.3.min.js\"))\n  assert(splash:go(splash.args.url))\n  local version = splash:evaljs(\"$.fn.jquery\")\n\n  return 'JQuery version: ' .. version\nend\n\nTo disable URL auto-detection use 'source' and 'url' arguments:\n\n.. code-block:: lua\n\n    splash:autoload{url=\"https://code.jquery.com/jquery-2.1.3.min.js\"}\n    splash:autoload{source=\"window.foo = 'bar';\"}\n\nIt is a good practice not to rely on auto-detection when the argument\nis not a constant.\n\nIf :ref:`splash-autoload` is called multiple times then all its scripts\nare executed on page load, in order they were added.\n\nTo revert Splash not to execute anything on page load use\n:ref:`splash-autoload-reset`.\n\nSee also: :ref:`splash-evaljs`, :ref:`splash-runjs`, :ref:`splash-jsfunc`,\n:ref:`splash-wait-for-resume`, :ref:`splash-autoload-reset`.",
    "params": "* source_or_url - either a string with JavaScript source code or an URL\n  to load the JavaScript code from;\n* source - a string with JavaScript source code;\n* url - an URL to load JavaScript source code from."
  },
  "splash:autoload_reset": {
    "name": "autoload_reset",
    "header": "splash:autoload_reset",
    "content": "Unregister all scripts previously set by :ref:`splash-autoload`.\n\n**Signature:** ``splash:autoload_reset()``\n\n**Returns:** nil\n\n**Async:** no\n\nAfter :ref:`splash-autoload-reset` call scripts set by :ref:`splash-autoload`\nwon't be loaded in future requests; one can use :ref:`splash-autoload` again\nto setup a different set of scripts.\n\nAlready loaded scripts are not removed from the current page context.\n\nSee also: :ref:`splash-autoload`.",
    "short": "Unregister all scripts previously set by :ref:`splash-autoload`.",
    "signature": "splash:autoload_reset()",
    "returns": "nil",
    "async": "no",
    "details": "After :ref:`splash-autoload-reset` call scripts set by :ref:`splash-autoload`\nwon't be loaded in future requests; one can use :ref:`splash-autoload` again\nto setup a different set of scripts.\n\nAlready loaded scripts are not removed from the current page context.\n\nSee also: :ref:`splash-autoload`.",
    "params": null
  },
  "splash:call_later": {
    "name": "call_later",
    "header": "splash:call_later",
    "content": "Arrange for the callback to be called after the given delay seconds.\n\n**Signature:** ``timer = splash:call_later(callback, delay)``\n\n**Parameters:**\n\n* callback - function to run;\n* delay - delay, in seconds;\n\n**Returns:** a handle which allows to cancel pending timer or reraise\nexceptions happened in a callback.\n\n**Async:** no.\n\nExample 1 - take two HTML snapshots, at 1.5s and 2.5s after page\nloading starts:\n\nfunction main(splash, args)\n  local snapshots = {}\n  local timer = splash:call_later(function()\n    snapshots[\"a\"] = splash:html()\n    splash:wait(1.0)\n    snapshots[\"b\"] = splash:html()\n  end, 1.5)\n  assert(splash:go(args.url))\n  splash:wait(3.0)\n  timer:reraise()\n\n  return snapshots\nend\n:ref:`splash-call-later` returns a handle (a ``timer``). To cancel pending\ntask use its ``timer:cancel()`` method. If a callback is already\nstarted ``timer:cancel()`` has no effect.\n\nBy default, exceptions raised in :ref:`splash-call-later` callback\nstop the callback, but don't stop the main script. To reraise these errors\nuse ``timer:reraise()``.\n\n:ref:`splash-call-later` arranges callback to be executed in future;\nit never runs it immediately, even if delay is 0. When delay is 0\ncallback is executed no earlier than current function yields to event loop,\ni.e. no earlier than some of the async functions is called.",
    "short": "Arrange for the callback to be called after the given delay seconds.",
    "signature": "timer = splash:call_later(callback, delay)",
    "returns": "a handle which allows to cancel pending timer or reraise\nexceptions happened in a callback.",
    "async": "no.",
    "details": "Example 1 - take two HTML snapshots, at 1.5s and 2.5s after page\nloading starts:\n\nfunction main(splash, args)\n  local snapshots = {}\n  local timer = splash:call_later(function()\n    snapshots[\"a\"] = splash:html()\n    splash:wait(1.0)\n    snapshots[\"b\"] = splash:html()\n  end, 1.5)\n  assert(splash:go(args.url))\n  splash:wait(3.0)\n  timer:reraise()\n\n  return snapshots\nend\n:ref:`splash-call-later` returns a handle (a ``timer``). To cancel pending\ntask use its ``timer:cancel()`` method. If a callback is already\nstarted ``timer:cancel()`` has no effect.\n\nBy default, exceptions raised in :ref:`splash-call-later` callback\nstop the callback, but don't stop the main script. To reraise these errors\nuse ``timer:reraise()``.\n\n:ref:`splash-call-later` arranges callback to be executed in future;\nit never runs it immediately, even if delay is 0. When delay is 0\ncallback is executed no earlier than current function yields to event loop,\ni.e. no earlier than some of the async functions is called.",
    "params": "* callback - function to run;\n* delay - delay, in seconds;"
  },
  "splash:http_get": {
    "name": "http_get",
    "header": "splash:http_get",
    "content": "Send an HTTP GET request and return a response without loading\nthe result to the browser window.\n\n**Signature:** ``response = splash:http_get{url, headers=nil, follow_redirects=true}``\n\n**Parameters:**\n\n* url - URL to load;\n* headers - a Lua table with HTTP headers to add/replace in the initial request;\n* follow_redirects - whether to follow HTTP redirects.\n\n**Returns:** a :ref:`splash-response`.\n\n**Async:** yes.\n\nExample:\n\n.. code-block:: lua\n\n    local reply = splash:http_get(\"http://example.com\")\n\nThis method doesn't change the current page contents and URL.\nTo load a webpage to the browser use :ref:`splash-go`.\n\nSee also: :ref:`splash-http-post`, :ref:`splash-response`.",
    "short": "Send an HTTP GET request and return a response without loading\nthe result to the browser window.",
    "signature": "response = splash:http_get{url, headers=nil, follow_redirects=true}",
    "returns": "a :ref:`splash-response`.",
    "async": "yes.",
    "details": "Example:\n\n.. code-block:: lua\n\n    local reply = splash:http_get(\"http://example.com\")\n\nThis method doesn't change the current page contents and URL.\nTo load a webpage to the browser use :ref:`splash-go`.\n\nSee also: :ref:`splash-http-post`, :ref:`splash-response`.",
    "params": "* url - URL to load;\n* headers - a Lua table with HTTP headers to add/replace in the initial request;\n* follow_redirects - whether to follow HTTP redirects."
  },
  "splash:http_post": {
    "name": "http_post",
    "header": "splash:http_post",
    "content": "Send an HTTP POST request and return a response without loading\nthe result to the browser window.\n\n**Signature:** ``response = splash:http_post{url, headers=nil, follow_redirects=true, body=nil}``\n\n**Parameters:**\n\n* url - URL to load;\n* headers - a Lua table with HTTP headers to add/replace in the initial request;\n* follow_redirects - whether to follow HTTP redirects.\n* body - string with body of request, if you intend to send form submission,\n  body should be urlencoded.\n\n**Returns:** a :ref:`splash-response`.\n\n**Async:** yes.\n\nExample of form submission:\n\n.. code-block:: lua\n\n    local reply = splash:http_post{url=\"http://example.com\", body=\"user=Frank&password=hunter2\"}\n    -- reply.body contains raw HTML data (as a binary object)\n    -- reply.status contains HTTP status code, as a number\n    -- see Response docs for more info\n\nExample of JSON POST request:\n\n.. code-block:: lua\n\n    json = require(\"json\")\n\n    local reply = splash:http_post{\n        url=\"http://example.com/post\",\n        body=json.encode({alpha=\"beta\"}),\n        headers={[\"content-type\"]=\"application/json\"}\n    }\n\n\nThis method doesn't change the current page contents and URL.\nTo load a webpage to the browser use :ref:`splash-go`.\n\nSee also: :ref:`splash-http-get`, :ref:`lib-json`, :ref:`splash-response`.",
    "short": "Send an HTTP POST request and return a response without loading\nthe result to the browser window.",
    "signature": "response = splash:http_post{url, headers=nil, follow_redirects=true, body=nil}",
    "returns": "a :ref:`splash-response`.",
    "async": "yes.",
    "details": "Example of form submission:\n\n.. code-block:: lua\n\n    local reply = splash:http_post{url=\"http://example.com\", body=\"user=Frank&password=hunter2\"}\n    -- reply.body contains raw HTML data (as a binary object)\n    -- reply.status contains HTTP status code, as a number\n    -- see Response docs for more info\n\nExample of JSON POST request:\n\n.. code-block:: lua\n\n    json = require(\"json\")\n\n    local reply = splash:http_post{\n        url=\"http://example.com/post\",\n        body=json.encode({alpha=\"beta\"}),\n        headers={[\"content-type\"]=\"application/json\"}\n    }\n\n\nThis method doesn't change the current page contents and URL.\nTo load a webpage to the browser use :ref:`splash-go`.\n\nSee also: :ref:`splash-http-get`, :ref:`lib-json`, :ref:`splash-response`.",
    "params": "* url - URL to load;\n* headers - a Lua table with HTTP headers to add/replace in the initial request;\n* follow_redirects - whether to follow HTTP redirects.\n* body - string with body of request, if you intend to send form submission,\n  body should be urlencoded."
  },
  "splash:set_content": {
    "name": "set_content",
    "header": "splash:set_content",
    "content": "Set the content of the current page and wait until the page loads.\n\n**Signature:** ``ok, reason = splash:set_content{data, mime_type=\"text/html; charset=utf-8\", baseurl=\"\"}``\n\n**Parameters:**\n\n* data - new page content;\n* mime_type - MIME type of the content;\n* baseurl - external objects referenced in the content are located\n  relative to baseurl.\n\n**Returns:** ``ok, reason`` pair. If ``ok`` is nil then error happened during\npage load; ``reason`` provides an information about error type.\n\n**Async:** yes.\n\nExample:\n\n.. code-block:: lua\n\n    function main(splash)\n        assert(splash:set_content(\"<html><body><h1>hello</h1></body></html>\"))\n        return splash:png()\n    end",
    "short": "Set the content of the current page and wait until the page loads.",
    "signature": "ok, reason = splash:set_content{data, mime_type=\"text/html; charset=utf-8\", baseurl=\"\"}",
    "returns": "``ok, reason`` pair. If ``ok`` is nil then error happened during\npage load; ``reason`` provides an information about error type.",
    "async": "yes.",
    "details": "Example:\n\n.. code-block:: lua\n\n    function main(splash)\n        assert(splash:set_content(\"<html><body><h1>hello</h1></body></html>\"))\n        return splash:png()\n    end",
    "params": "* data - new page content;\n* mime_type - MIME type of the content;\n* baseurl - external objects referenced in the content are located\n  relative to baseurl."
  },
  "splash:html": {
    "name": "html",
    "header": "splash:html",
    "content": "Return a HTML snapshot of a current page (as a string).\n\n**Signature:** ``html = splash:html()``\n\n**Returns:** contents of a current page (as a string).\n\n**Async:** no.\n\nExample:\n\n.. code-block:: lua\n\n     -- A simplistic implementation of render.html endpoint\n     function main(splash)\n         splash:set_result_content_type(\"text/html; charset=utf-8\")\n         assert(splash:go(splash.args.url))\n         return splash:html()\n     end\n\nNothing prevents us from taking multiple HTML snapshots. For example, let's\nvisit first 3 pages on a website, and for each page store\ninitial HTML snapshot and an HTML snapshot after waiting 0.5s:\n\ntreat = require(\"treat\")\n\n-- Given an url, this function returns a table\n-- with the page screenshoot, it's HTML contents\n-- and it's title.\nfunction page_info(splash, url)\n  local ok, msg = splash:go(url)\n  if not ok then\n    return {ok=false, reason=msg}\n  end\n  local res = {\n    html=splash:html(),\n    title=splash:evaljs('document.title'),\n    image=splash:png(),\n    ok=true,\n  }\n  return res\nend\n\nfunction main(splash, args)\n  -- visit first 3 pages of hacker news\n  local base = \"https://news.ycombinator.com/news?p=\"\n  local result = treat.as_array({})\n  for i=1,3 do\n    local url =  base .. i\n    result[i] = page_info(splash, url)\n  end\n  return result\nend",
    "short": "Return a HTML snapshot of a current page (as a string).",
    "signature": "html = splash:html()",
    "returns": "contents of a current page (as a string).",
    "async": "no.",
    "details": "Example:\n\n.. code-block:: lua\n\n     -- A simplistic implementation of render.html endpoint\n     function main(splash)\n         splash:set_result_content_type(\"text/html; charset=utf-8\")\n         assert(splash:go(splash.args.url))\n         return splash:html()\n     end\n\nNothing prevents us from taking multiple HTML snapshots. For example, let's\nvisit first 3 pages on a website, and for each page store\ninitial HTML snapshot and an HTML snapshot after waiting 0.5s:\n\ntreat = require(\"treat\")\n\n-- Given an url, this function returns a table\n-- with the page screenshoot, it's HTML contents\n-- and it's title.\nfunction page_info(splash, url)\n  local ok, msg = splash:go(url)\n  if not ok then\n    return {ok=false, reason=msg}\n  end\n  local res = {\n    html=splash:html(),\n    title=splash:evaljs('document.title'),\n    image=splash:png(),\n    ok=true,\n  }\n  return res\nend\n\nfunction main(splash, args)\n  -- visit first 3 pages of hacker news\n  local base = \"https://news.ycombinator.com/news?p=\"\n  local result = treat.as_array({})\n  for i=1,3 do\n    local url =  base .. i\n    result[i] = page_info(splash, url)\n  end\n  return result\nend",
    "params": null
  },
  "splash:png": {
    "name": "png",
    "header": "splash:png",
    "content": "Return a `width x height` screenshot of a current page in PNG format.\n\n**Signature:** ``png = splash:png{width=nil, height=nil, render_all=false, scale_method='raster', region=nil}``\n\n**Parameters:**\n\n* width - optional, width of a screenshot in pixels;\n* height - optional, height of a screenshot in pixels;\n* render_all - optional, if ``true`` render the whole webpage;\n* scale_method - optional, method to use when resizing the image, ``'raster'``\n  or ``'vector'``;\n* region - optional, ``{left, top, right, bottom}`` coordinates of\n  a cropping rectangle.\n\n**Returns:** PNG screenshot data, as a :ref:`binary object <binary-objects>`.\nWhen the result is empty ``nil`` is returned.\n\n**Async:** no.\n\nWithout arguments ``splash:png()`` will take a snapshot of the current viewport.\n\n*width* parameter sets the width of the resulting image.  If the viewport has a\ndifferent width, the image is scaled up or down to match the specified one.\nFor example, if the viewport is 1024px wide then ``splash:png{width=100}`` will\nreturn a screenshot of the whole viewport, but the image will be downscaled to\n100px width.\n\n*height* parameter sets the height of the resulting image.  If the viewport has\na different height, the image is trimmed or extended vertically to match the\nspecified one without resizing the content.  The region created by such\nextension is transparent.\n\nTo set the viewport size use :ref:`splash-set-viewport-size`,\n:ref:`splash-set-viewport-full` or *render_all* argument.  ``render_all=true``\nis equivalent to running ``splash:set_viewport_full()`` just before the\nrendering and restoring the viewport size afterwards.\n\nTo render an arbitrary part of a page use *region* parameter. It should\nbe a table with ``{left, top, right, bottom}`` coordinates. Coordinates\nare relative to current scroll position. Currently you can't take anything\nwhich is not in a viewport; to make sure part of a page can be rendered call\n:ref:`splash-set-viewport-full` before using :ref:`splash-png` with *region*.\nThis may be fixed in future Splash versions.\n\n.. _example-render-element:\n\nWith ``region`` and a bit of JavaScript it is possible to render only a single\nHTML element. Example:\n\n-- This in an example of how to use lower-level\n-- Splash functions to get element screenshot.\n--\n-- In practice use splash:select(\"a\"):png{pad=32}.\n\n\n-- this function adds padding around region\nfunction pad(r, pad)\n  return {r[1]-pad, r[2]-pad, r[3]+pad, r[4]+pad}\nend\n\nfunction main(splash, args)\n  -- this function returns element bounding box\n  local get_bbox = splash:jsfunc([[\n    function(css) {\n      var el = document.querySelector(css);\n      var r = el.getBoundingClientRect();\n      return [r.left, r.top, r.right, r.bottom];\n    }\n  ]])\n\n  -- main script\n  assert(splash:go(splash.args.url))\n  assert(splash:wait(0.5))\n\n  -- don't crop image by a viewport\n  splash:set_viewport_full()\n\n  -- let's get a screenshot of a first <a>\n  -- element on a page, with extra 32px around it\n  local region = pad(get_bbox(\"a\"), 32)\n  return splash:png{region=region}\nend\nAn easier way is to use :ref:`splash-element-png` instead:\n\n.. code-block:: lua\n\n    splash:select('#my-element'):png()\n\n*scale_method* parameter must be either ``'raster'`` or ``'vector'``.  When\n``scale_method='raster'``, the image is resized per-pixel.  When\n``scale_method='vector'``, the image is resized per-element during rendering.\nVector scaling is more performant and produces sharper images, however it may\ncause rendering artifacts, so use it with caution.\n\nThe result of ``splash:png`` is a :ref:`binary object <binary-objects>`,\nso you can return it directly from \"main\" function and it will be sent as\na binary image data with a proper Content-Type header:\n\n-- A simplistic implementation of render.png\n-- endpoint.\nfunction main(splash, args)\n  assert(splash:go(args.url))\n\n  return splash:png{\n    width=args.width,\n    height=args.height\n  }\nend\nIf the result of ``splash:png()`` is returned as a table value, it is encoded\nto base64 to make it possible to embed in JSON and build a data:uri\non a client (magic!):\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         return {png=splash:png()}\n     end\n\nWhen an image is empty :ref:`splash-png` returns ``nil``. If you want Splash to\nraise an error in these cases use ``assert``:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         local png = assert(splash:png())\n         return {png=png}\n     end\n\nSee also: :ref:`splash-jpeg`, :ref:`binary-objects`,\n:ref:`splash-set-viewport-size`, :ref:`splash-set-viewport-full`,\n:ref:`splash-element-jpeg`, :ref:`splash-element-png`.",
    "short": "Return a `width x height` screenshot of a current page in PNG format.",
    "signature": "png = splash:png{width=nil, height=nil, render_all=false, scale_method='raster', region=nil}",
    "returns": "PNG screenshot data, as a :ref:`binary object <binary-objects>`.\nWhen the result is empty ``nil`` is returned.",
    "async": "no.",
    "details": "Without arguments ``splash:png()`` will take a snapshot of the current viewport.\n\n*width* parameter sets the width of the resulting image.  If the viewport has a\ndifferent width, the image is scaled up or down to match the specified one.\nFor example, if the viewport is 1024px wide then ``splash:png{width=100}`` will\nreturn a screenshot of the whole viewport, but the image will be downscaled to\n100px width.\n\n*height* parameter sets the height of the resulting image.  If the viewport has\na different height, the image is trimmed or extended vertically to match the\nspecified one without resizing the content.  The region created by such\nextension is transparent.\n\nTo set the viewport size use :ref:`splash-set-viewport-size`,\n:ref:`splash-set-viewport-full` or *render_all* argument.  ``render_all=true``\nis equivalent to running ``splash:set_viewport_full()`` just before the\nrendering and restoring the viewport size afterwards.\n\nTo render an arbitrary part of a page use *region* parameter. It should\nbe a table with ``{left, top, right, bottom}`` coordinates. Coordinates\nare relative to current scroll position. Currently you can't take anything\nwhich is not in a viewport; to make sure part of a page can be rendered call\n:ref:`splash-set-viewport-full` before using :ref:`splash-png` with *region*.\nThis may be fixed in future Splash versions.\n\n.. _example-render-element:\n\nWith ``region`` and a bit of JavaScript it is possible to render only a single\nHTML element. Example:\n\n-- This in an example of how to use lower-level\n-- Splash functions to get element screenshot.\n--\n-- In practice use splash:select(\"a\"):png{pad=32}.\n\n\n-- this function adds padding around region\nfunction pad(r, pad)\n  return {r[1]-pad, r[2]-pad, r[3]+pad, r[4]+pad}\nend\n\nfunction main(splash, args)\n  -- this function returns element bounding box\n  local get_bbox = splash:jsfunc([[\n    function(css) {\n      var el = document.querySelector(css);\n      var r = el.getBoundingClientRect();\n      return [r.left, r.top, r.right, r.bottom];\n    }\n  ]])\n\n  -- main script\n  assert(splash:go(splash.args.url))\n  assert(splash:wait(0.5))\n\n  -- don't crop image by a viewport\n  splash:set_viewport_full()\n\n  -- let's get a screenshot of a first <a>\n  -- element on a page, with extra 32px around it\n  local region = pad(get_bbox(\"a\"), 32)\n  return splash:png{region=region}\nend\nAn easier way is to use :ref:`splash-element-png` instead:\n\n.. code-block:: lua\n\n    splash:select('#my-element'):png()\n\n*scale_method* parameter must be either ``'raster'`` or ``'vector'``.  When\n``scale_method='raster'``, the image is resized per-pixel.  When\n``scale_method='vector'``, the image is resized per-element during rendering.\nVector scaling is more performant and produces sharper images, however it may\ncause rendering artifacts, so use it with caution.\n\nThe result of ``splash:png`` is a :ref:`binary object <binary-objects>`,\nso you can return it directly from \"main\" function and it will be sent as\na binary image data with a proper Content-Type header:\n\n-- A simplistic implementation of render.png\n-- endpoint.\nfunction main(splash, args)\n  assert(splash:go(args.url))\n\n  return splash:png{\n    width=args.width,\n    height=args.height\n  }\nend\nIf the result of ``splash:png()`` is returned as a table value, it is encoded\nto base64 to make it possible to embed in JSON and build a data:uri\non a client (magic!):\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         return {png=splash:png()}\n     end\n\nWhen an image is empty :ref:`splash-png` returns ``nil``. If you want Splash to\nraise an error in these cases use ``assert``:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         local png = assert(splash:png())\n         return {png=png}\n     end\n\nSee also: :ref:`splash-jpeg`, :ref:`binary-objects`,\n:ref:`splash-set-viewport-size`, :ref:`splash-set-viewport-full`,\n:ref:`splash-element-jpeg`, :ref:`splash-element-png`.",
    "params": "* width - optional, width of a screenshot in pixels;\n* height - optional, height of a screenshot in pixels;\n* render_all - optional, if ``true`` render the whole webpage;\n* scale_method - optional, method to use when resizing the image, ``'raster'``\n  or ``'vector'``;\n* region - optional, ``{left, top, right, bottom}`` coordinates of\n  a cropping rectangle."
  },
  "splash:jpeg": {
    "name": "jpeg",
    "header": "splash:jpeg",
    "content": "Return a `width x height` screenshot of a current page in JPEG format.\n\n**Signature:** ``jpeg = splash:jpeg{width=nil, height=nil, render_all=false, scale_method='raster', quality=75, region=nil}``\n\n**Parameters:**\n\n* width - optional, width of a screenshot in pixels;\n* height - optional, height of a screenshot in pixels;\n* render_all - optional, if ``true`` render the whole webpage;\n* scale_method - optional, method to use when resizing the image, ``'raster'``\n  or ``'vector'``;\n* quality - optional, quality of JPEG image, integer in range from ``0`` to ``100``;\n* region - optional, ``{left, top, right, bottom}`` coordinates of\n  a cropping rectangle.\n\n**Returns:** JPEG screenshot data, as a :ref:`binary object <binary-objects>`.\nWhen the image is empty ``nil`` is returned.\n\n**Async:** no.\n\nWithout arguments ``splash:jpeg()`` will take a snapshot of the current viewport.\n\n*width* parameter sets the width of the resulting image.  If the viewport has a\ndifferent width, the image is scaled up or down to match the specified one.\nFor example, if the viewport is 1024px wide then ``splash:jpeg{width=100}`` will\nreturn a screenshot of the whole viewport, but the image will be downscaled to\n100px width.\n\n*height* parameter sets the height of the resulting image.  If the viewport has\na different height, the image is trimmed or extended vertically to match the\nspecified one without resizing the content.  The region created by such\nextension is white.\n\nTo set the viewport size use :ref:`splash-set-viewport-size`,\n:ref:`splash-set-viewport-full` or *render_all* argument.  ``render_all=true``\nis equivalent to running ``splash:set_viewport_full()`` just before the\nrendering and restoring the viewport size afterwards.\n\nTo render an arbitrary part of a page use *region* parameter. It should\nbe a table with ``{left, top, right, bottom}`` coordinates. Coordinates\nare relative to current scroll position. Currently you can't take anything\nwhich is not in a viewport; to make sure part of a page can be rendered call\n:ref:`splash-set-viewport-full` before using :ref:`splash-jpeg` with *region*.\nThis may be fixed in future Splash versions.\n\nWith some JavaScript it is possible to render only a single HTML element\nusing ``region`` parameter. See an :ref:`example <example-render-element>`\nin :ref:`splash-png` docs. An alternative is to use :ref:`splash-element-jpeg`.\n\n*scale_method* parameter must be either ``'raster'`` or ``'vector'``.  When\n``scale_method='raster'``, the image is resized per-pixel.  When\n``scale_method='vector'``, the image is resized per-element during rendering.\nVector scaling is more performant and produces sharper images, however it may\ncause rendering artifacts, so use it with caution.\n\n*quality* parameter must be an integer in range from ``0`` to ``100``.\nValues above ``95`` should be avoided; ``quality=100`` disables portions of\nthe JPEG compression algorithm, and results in large files with hardly any\ngain in image quality.\n\nThe result of ``splash:jpeg`` is a :ref:`binary object <binary-objects>`,\nso you can return it directly from \"main\" function and it will be sent as\na binary image data with a proper Content-Type header:\n\n.. code-block:: lua\n\n     -- A simplistic implementation of render.jpeg endpoint\n     function main(splash, args)\n         assert(splash:go(args.url))\n         return splash:jpeg{\n            width=args.width,\n            height=args.height\n         }\n     end\n\nIf the result of ``splash:jpeg()`` is returned as a table value, it is encoded\nto base64 to make it possible to embed in JSON and build a data:uri\non a client:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         return {jpeg=splash:jpeg()}\n     end\n\nWhen an image is empty :ref:`splash-jpeg` returns ``nil``. If you want Splash to\nraise an error in these cases use `assert`:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         local jpeg = assert(splash:jpeg())\n         return {jpeg=jpeg}\n     end\n\nSee also: :ref:`splash-png`, :ref:`binary-objects`,\n:ref:`splash-set-viewport-size`, :ref:`splash-set-viewport-full`,\n:ref:`splash-element-jpeg`, :ref:`splash-element-png`.\n\nNote that ``splash:jpeg()`` is often 1.5..2x faster than ``splash:png()``.",
    "short": "Return a `width x height` screenshot of a current page in JPEG format.",
    "signature": "jpeg = splash:jpeg{width=nil, height=nil, render_all=false, scale_method='raster', quality=75, region=nil}",
    "returns": "JPEG screenshot data, as a :ref:`binary object <binary-objects>`.\nWhen the image is empty ``nil`` is returned.",
    "async": "no.",
    "details": "Without arguments ``splash:jpeg()`` will take a snapshot of the current viewport.\n\n*width* parameter sets the width of the resulting image.  If the viewport has a\ndifferent width, the image is scaled up or down to match the specified one.\nFor example, if the viewport is 1024px wide then ``splash:jpeg{width=100}`` will\nreturn a screenshot of the whole viewport, but the image will be downscaled to\n100px width.\n\n*height* parameter sets the height of the resulting image.  If the viewport has\na different height, the image is trimmed or extended vertically to match the\nspecified one without resizing the content.  The region created by such\nextension is white.\n\nTo set the viewport size use :ref:`splash-set-viewport-size`,\n:ref:`splash-set-viewport-full` or *render_all* argument.  ``render_all=true``\nis equivalent to running ``splash:set_viewport_full()`` just before the\nrendering and restoring the viewport size afterwards.\n\nTo render an arbitrary part of a page use *region* parameter. It should\nbe a table with ``{left, top, right, bottom}`` coordinates. Coordinates\nare relative to current scroll position. Currently you can't take anything\nwhich is not in a viewport; to make sure part of a page can be rendered call\n:ref:`splash-set-viewport-full` before using :ref:`splash-jpeg` with *region*.\nThis may be fixed in future Splash versions.\n\nWith some JavaScript it is possible to render only a single HTML element\nusing ``region`` parameter. See an :ref:`example <example-render-element>`\nin :ref:`splash-png` docs. An alternative is to use :ref:`splash-element-jpeg`.\n\n*scale_method* parameter must be either ``'raster'`` or ``'vector'``.  When\n``scale_method='raster'``, the image is resized per-pixel.  When\n``scale_method='vector'``, the image is resized per-element during rendering.\nVector scaling is more performant and produces sharper images, however it may\ncause rendering artifacts, so use it with caution.\n\n*quality* parameter must be an integer in range from ``0`` to ``100``.\nValues above ``95`` should be avoided; ``quality=100`` disables portions of\nthe JPEG compression algorithm, and results in large files with hardly any\ngain in image quality.\n\nThe result of ``splash:jpeg`` is a :ref:`binary object <binary-objects>`,\nso you can return it directly from \"main\" function and it will be sent as\na binary image data with a proper Content-Type header:\n\n.. code-block:: lua\n\n     -- A simplistic implementation of render.jpeg endpoint\n     function main(splash, args)\n         assert(splash:go(args.url))\n         return splash:jpeg{\n            width=args.width,\n            height=args.height\n         }\n     end\n\nIf the result of ``splash:jpeg()`` is returned as a table value, it is encoded\nto base64 to make it possible to embed in JSON and build a data:uri\non a client:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         return {jpeg=splash:jpeg()}\n     end\n\nWhen an image is empty :ref:`splash-jpeg` returns ``nil``. If you want Splash to\nraise an error in these cases use `assert`:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         local jpeg = assert(splash:jpeg())\n         return {jpeg=jpeg}\n     end\n\nSee also: :ref:`splash-png`, :ref:`binary-objects`,\n:ref:`splash-set-viewport-size`, :ref:`splash-set-viewport-full`,\n:ref:`splash-element-jpeg`, :ref:`splash-element-png`.\n\nNote that ``splash:jpeg()`` is often 1.5..2x faster than ``splash:png()``.",
    "params": "* width - optional, width of a screenshot in pixels;\n* height - optional, height of a screenshot in pixels;\n* render_all - optional, if ``true`` render the whole webpage;\n* scale_method - optional, method to use when resizing the image, ``'raster'``\n  or ``'vector'``;\n* quality - optional, quality of JPEG image, integer in range from ``0`` to ``100``;\n* region - optional, ``{left, top, right, bottom}`` coordinates of\n  a cropping rectangle."
  },
  "splash:har": {
    "name": "har",
    "header": "splash:har",
    "content": "**Signature:** ``har = splash:har{reset=false}``\n\n**Parameters:**\n\n* reset - optional; when ``true``, reset HAR records after taking a snapshot.\n\n**Returns:** information about pages loaded, events happened,\nnetwork requests sent and responses received in HAR_ format.\n\n**Async:** no.\n\nUse :ref:`splash-har` to get information about network requests and\nother Splash activity.\n\nIf your script returns the result of ``splash:har()`` in a top-level\n``\"har\"`` key then Splash UI will give you a nice diagram with network\ninformation (similar to \"Network\" tabs in Firefox or Chrome developer tools):\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         return {har=splash:har()}\n     end\n\nBy default, when several requests are made (e.g. :ref:`splash-go` is called\nmultiple times), HAR data is accumulated and combined into a single object\n(logs are still grouped by page).\n\nIf you want only updated information use ``reset`` parameter: it drops\nall existing logs and start recording from scratch:\n\n.. code-block:: lua\n\n     function main(splash, args)\n         assert(splash:go(args.url1))\n         local har1 = splash:har{reset=true}\n         assert(splash:go(args.url2))\n         local har2 = splash:har()\n         return {har1=har1, har2=har2}\n     end\n\nBy default, response content is not returned in HAR data. To enable it, use\n:ref:`splash-response-body-enabled` option or\n:ref:`splash-request-enable-response-body` method.\n\nSee also: :ref:`splash-har-reset`, :ref:`splash-on-response`,\n:ref:`splash-response-body-enabled`, :ref:`splash-request-enable-response-body`.\n\n.. _HAR: http://www.softwareishard.com/blog/har-12-spec/",
    "short": "",
    "signature": "har = splash:har{reset=false}",
    "returns": "information about pages loaded, events happened,\nnetwork requests sent and responses received in HAR_ format.",
    "async": "no.",
    "details": "Use :ref:`splash-har` to get information about network requests and\nother Splash activity.\n\nIf your script returns the result of ``splash:har()`` in a top-level\n``\"har\"`` key then Splash UI will give you a nice diagram with network\ninformation (similar to \"Network\" tabs in Firefox or Chrome developer tools):\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         return {har=splash:har()}\n     end\n\nBy default, when several requests are made (e.g. :ref:`splash-go` is called\nmultiple times), HAR data is accumulated and combined into a single object\n(logs are still grouped by page).\n\nIf you want only updated information use ``reset`` parameter: it drops\nall existing logs and start recording from scratch:\n\n.. code-block:: lua\n\n     function main(splash, args)\n         assert(splash:go(args.url1))\n         local har1 = splash:har{reset=true}\n         assert(splash:go(args.url2))\n         local har2 = splash:har()\n         return {har1=har1, har2=har2}\n     end\n\nBy default, response content is not returned in HAR data. To enable it, use\n:ref:`splash-response-body-enabled` option or\n:ref:`splash-request-enable-response-body` method.\n\nSee also: :ref:`splash-har-reset`, :ref:`splash-on-response`,\n:ref:`splash-response-body-enabled`, :ref:`splash-request-enable-response-body`.\n\n.. _HAR: http://www.softwareishard.com/blog/har-12-spec/",
    "params": "* reset - optional; when ``true``, reset HAR records after taking a snapshot."
  },
  "splash:har_reset": {
    "name": "har_reset",
    "header": "splash:har_reset",
    "content": "**Signature:** ``splash:har_reset()``\n\n**Returns:** nil.\n\n**Async:** no.\n\nDrops all internally stored HAR_ records. It is similar to\n``splash:har{reset=true}``, but doesn't return anything.\n\nSee also: :ref:`splash-har`.",
    "short": "",
    "signature": "splash:har_reset()",
    "returns": "nil.",
    "async": "no.",
    "details": "Drops all internally stored HAR_ records. It is similar to\n``splash:har{reset=true}``, but doesn't return anything.\n\nSee also: :ref:`splash-har`.",
    "params": null
  },
  "splash:history": {
    "name": "history",
    "header": "splash:history",
    "content": "**Signature:** ``entries = splash:history()``\n\n**Returns:** information about requests/responses for the pages loaded, in\n`HAR entries`_ format.\n\n**Async:** no.\n\n``splash:history`` doesn't return information about related resources\nlike images, scripts, stylesheets or AJAX requests. If you need this\ninformation use :ref:`splash-har` or :ref:`splash-on-response`.\n\nLet's get a JSON array with HTTP headers of the response we're displaying:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         local entries = splash:history()\n         -- #entries means \"entries length\"; arrays in Lua start from 1\n         local last_entry = entries[#entries]\n         return {\n            headers = last_entry.response.headers\n         }\n     end\n\nSee also: :ref:`splash-har`, :ref:`splash-on-response`.\n\n.. _HAR entries: http://www.softwareishard.com/blog/har-12-spec/#entries",
    "short": "",
    "signature": "entries = splash:history()",
    "returns": "information about requests/responses for the pages loaded, in\n`HAR entries`_ format.",
    "async": "no.",
    "details": "``splash:history`` doesn't return information about related resources\nlike images, scripts, stylesheets or AJAX requests. If you need this\ninformation use :ref:`splash-har` or :ref:`splash-on-response`.\n\nLet's get a JSON array with HTTP headers of the response we're displaying:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(splash.args.url))\n         local entries = splash:history()\n         -- #entries means \"entries length\"; arrays in Lua start from 1\n         local last_entry = entries[#entries]\n         return {\n            headers = last_entry.response.headers\n         }\n     end\n\nSee also: :ref:`splash-har`, :ref:`splash-on-response`.\n\n.. _HAR entries: http://www.softwareishard.com/blog/har-12-spec/#entries",
    "params": null
  },
  "splash:url": {
    "name": "url",
    "header": "splash:url",
    "content": "**Signature:** ``url = splash:url()``\n\n**Returns:** the current URL.\n\n**Async:** no.",
    "short": "",
    "signature": "url = splash:url()",
    "returns": "the current URL.",
    "async": "no.",
    "details": "",
    "params": null
  },
  "splash:get_cookies": {
    "name": "get_cookies",
    "header": "splash:get_cookies",
    "content": "**Signature:** ``cookies = splash:get_cookies()``\n\n**Returns:** CookieJar contents - an array with all cookies available\nfor the script. The result is returned in `HAR cookies`_ format.\n\n**Async:** no.\n\n.. _HAR cookies: http://www.softwareishard.com/blog/har-12-spec/#cookies\n\nExample result::\n\n    [\n        {\n            \"name\": \"TestCookie\",\n            \"value\": \"Cookie Value\",\n            \"path\": \"/\",\n            \"domain\": \"www.example.com\",\n            \"expires\": \"2016-07-24T19:20:30+02:00\",\n            \"httpOnly\": false,\n            \"secure\": false,\n        }\n    ]",
    "short": "",
    "signature": "cookies = splash:get_cookies()",
    "returns": "CookieJar contents - an array with all cookies available\nfor the script. The result is returned in `HAR cookies`_ format.",
    "async": "no.",
    "details": ".. _HAR cookies: http://www.softwareishard.com/blog/har-12-spec/#cookies\n\nExample result::\n\n    [\n        {\n            \"name\": \"TestCookie\",\n            \"value\": \"Cookie Value\",\n            \"path\": \"/\",\n            \"domain\": \"www.example.com\",\n            \"expires\": \"2016-07-24T19:20:30+02:00\",\n            \"httpOnly\": false,\n            \"secure\": false,\n        }\n    ]",
    "params": null
  },
  "splash:add_cookie": {
    "name": "add_cookie",
    "header": "splash:add_cookie",
    "content": "Add a cookie.\n\n**Signature:** ``cookies = splash:add_cookie{name, value, path=nil, domain=nil, expires=nil, httpOnly=nil, secure=nil}``\n\n**Async:** no.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:add_cookie{\"sessionid\", \"237465ghgfsd\", \"/\", domain=\"http://example.com\"}\n         splash:go(\"http://example.com/\")\n         return splash:html()\n     end",
    "short": "Add a cookie.",
    "signature": "cookies = splash:add_cookie{name, value, path=nil, domain=nil, expires=nil, httpOnly=nil, secure=nil}",
    "returns": null,
    "async": "no.",
    "details": "Example:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:add_cookie{\"sessionid\", \"237465ghgfsd\", \"/\", domain=\"http://example.com\"}\n         splash:go(\"http://example.com/\")\n         return splash:html()\n     end",
    "params": null
  },
  "splash:init_cookies": {
    "name": "init_cookies",
    "header": "splash:init_cookies",
    "content": "Replace all current cookies with the passed ``cookies``.\n\n**Signature:** ``splash:init_cookies(cookies)``\n\n**Parameters:**\n\n* cookies - a Lua table with all cookies to set, in the same format as\n  :ref:`splash-get-cookies` returns.\n\n**Returns:** nil.\n\n**Async:** no.\n\nExample 1 - save and restore cookies:\n\n.. code-block:: lua\n\n     local cookies = splash:get_cookies()\n     -- ... do something ...\n     splash:init_cookies(cookies)  -- restore cookies\n\nExample 2 - initialize cookies manually:\n\n.. code-block:: lua\n\n     splash:init_cookies({\n         {name=\"baz\", value=\"egg\"},\n         {name=\"spam\", value=\"egg\", domain=\"example.com\"},\n         {\n             name=\"foo\",\n             value=\"bar\",\n             path=\"/\",\n             domain=\"localhost\",\n             expires=\"2016-07-24T19:20:30+02:00\",\n             secure=true,\n             httpOnly=true,\n         }\n     })\n\n     -- do something\n     assert(splash:go(\"http://example.com\"))",
    "short": "Replace all current cookies with the passed ``cookies``.",
    "signature": "splash:init_cookies(cookies)",
    "returns": "nil.",
    "async": "no.",
    "details": "Example 1 - save and restore cookies:\n\n.. code-block:: lua\n\n     local cookies = splash:get_cookies()\n     -- ... do something ...\n     splash:init_cookies(cookies)  -- restore cookies\n\nExample 2 - initialize cookies manually:\n\n.. code-block:: lua\n\n     splash:init_cookies({\n         {name=\"baz\", value=\"egg\"},\n         {name=\"spam\", value=\"egg\", domain=\"example.com\"},\n         {\n             name=\"foo\",\n             value=\"bar\",\n             path=\"/\",\n             domain=\"localhost\",\n             expires=\"2016-07-24T19:20:30+02:00\",\n             secure=true,\n             httpOnly=true,\n         }\n     })\n\n     -- do something\n     assert(splash:go(\"http://example.com\"))",
    "params": "* cookies - a Lua table with all cookies to set, in the same format as\n  :ref:`splash-get-cookies` returns."
  },
  "splash:clear_cookies": {
    "name": "clear_cookies",
    "header": "splash:clear_cookies",
    "content": "Clear all cookies.\n\n**Signature:** ``n_removed = splash:clear_cookies()``\n\n**Returns:** a number of cookies deleted.\n\n**Async:** no.\n\nTo delete only specific cookies\nuse :ref:`splash-delete-cookies`.",
    "short": "Clear all cookies.",
    "signature": "n_removed = splash:clear_cookies()",
    "returns": "a number of cookies deleted.",
    "async": "no.",
    "details": "To delete only specific cookies\nuse :ref:`splash-delete-cookies`.",
    "params": null
  },
  "splash:delete_cookies": {
    "name": "delete_cookies",
    "header": "splash:delete_cookies",
    "content": "Delete matching cookies.\n\n**Signature:** ``n_removed = splash:delete_cookies{name=nil, url=nil}``\n\n**Parameters:**\n\n* name - a string, optional. All cookies with this name will be deleted.\n* url - a string, optional. Only cookies that should be sent to this url\n  will be deleted.\n\n**Returns:** a number of cookies deleted.\n\n**Async:** no.\n\nThis function does nothing when both *name* and *url* are nil.\nTo remove all cookies use :ref:`splash-clear-cookies` method.",
    "short": "Delete matching cookies.",
    "signature": "n_removed = splash:delete_cookies{name=nil, url=nil}",
    "returns": "a number of cookies deleted.",
    "async": "no.",
    "details": "This function does nothing when both *name* and *url* are nil.\nTo remove all cookies use :ref:`splash-clear-cookies` method.",
    "params": "* name - a string, optional. All cookies with this name will be deleted.\n* url - a string, optional. Only cookies that should be sent to this url\n  will be deleted."
  },
  "splash:lock_navigation": {
    "name": "lock_navigation",
    "header": "splash:lock_navigation",
    "content": "Lock navigation.\n\n**Signature:** ``splash:lock_navigation()``\n\n**Async:** no.\n\nAfter calling this method the navigation away from the current page is no\nlonger permitted - the page is locked to the current URL.",
    "short": "Lock navigation.",
    "signature": "splash:lock_navigation()",
    "returns": null,
    "async": "no.",
    "details": "After calling this method the navigation away from the current page is no\nlonger permitted - the page is locked to the current URL.",
    "params": null
  },
  "splash:unlock_navigation": {
    "name": "unlock_navigation",
    "header": "splash:unlock_navigation",
    "content": "Unlock navigation.\n\n**Signature:** ``splash:unlock_navigation()``\n\n**Async:** no.\n\nAfter calling this method the navigation away from the page becomes\npermitted. Note that the pending navigation requests suppressed\nby :ref:`splash-lock-navigation` won't be reissued.",
    "short": "Unlock navigation.",
    "signature": "splash:unlock_navigation()",
    "returns": null,
    "async": "no.",
    "details": "After calling this method the navigation away from the page becomes\npermitted. Note that the pending navigation requests suppressed\nby :ref:`splash-lock-navigation` won't be reissued.",
    "params": null
  },
  "splash:set_result_status_code": {
    "name": "set_result_status_code",
    "header": "splash:set_result_status_code",
    "content": "Set HTTP status code of a result returned to a client.\n\n**Signature:** ``splash:set_result_status_code(code)``\n\n**Parameters:**\n\n* code - HTTP status code (a number 200 <= code <= 999).\n\n**Returns:** nil.\n\n**Async:** no.\n\nUse this function to signal errors or other conditions to splash client\nusing HTTP status codes.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         local ok, reason = splash:go(\"http://www.example.com\")\n         if reason == \"http500\" then\n             splash:set_result_status_code(503)\n             splash:set_result_header(\"Retry-After\", 10)\n             return ''\n         end\n         return splash:png()\n     end\n\nBe careful with this function: some proxies can be configured to\nprocess responses differently based on their status codes. See e.g. nginx\n`proxy_next_upstream <http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream>`_\noption.\n\nIn case of unhandled Lua errors HTTP status code is set to 400 regardless\nof the value set with :ref:`splash-set-result-status-code`.\n\nSee also: :ref:`splash-set-result-content-type`,\n:ref:`splash-set-result-header`.",
    "short": "Set HTTP status code of a result returned to a client.",
    "signature": "splash:set_result_status_code(code)",
    "returns": "nil.",
    "async": "no.",
    "details": "Use this function to signal errors or other conditions to splash client\nusing HTTP status codes.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         local ok, reason = splash:go(\"http://www.example.com\")\n         if reason == \"http500\" then\n             splash:set_result_status_code(503)\n             splash:set_result_header(\"Retry-After\", 10)\n             return ''\n         end\n         return splash:png()\n     end\n\nBe careful with this function: some proxies can be configured to\nprocess responses differently based on their status codes. See e.g. nginx\n`proxy_next_upstream <http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream>`_\noption.\n\nIn case of unhandled Lua errors HTTP status code is set to 400 regardless\nof the value set with :ref:`splash-set-result-status-code`.\n\nSee also: :ref:`splash-set-result-content-type`,\n:ref:`splash-set-result-header`.",
    "params": "* code - HTTP status code (a number 200 <= code <= 999)."
  },
  "splash:set_result_content_type": {
    "name": "set_result_content_type",
    "header": "splash:set_result_content_type",
    "content": "Set Content-Type of a result returned to a client.\n\n**Signature:** ``splash:set_result_content_type(content_type)``\n\n**Parameters:**\n\n* content_type - a string with Content-Type header value.\n\n**Returns:** nil.\n\n**Async:** no.\n\nIf a table is returned by \"main\" function then\n``splash:set_result_content_type`` has no effect: Content-Type of the result\nis set to ``application/json``.\n\nThis function **does not** set Content-Type header for requests\ninitiated by :ref:`splash-go`; this function is for setting Content-Type\nheader of a result.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:set_result_content_type(\"text/xml\")\n         return [[\n            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <note>\n                <to>Tove</to>\n                <from>Jani</from>\n                <heading>Reminder</heading>\n                <body>Don't forget me this weekend!</body>\n            </note>\n         ]]\n     end\n\nSee also:\n\n* :ref:`splash-set-result-header` which allows to set any custom\n  response header, not only Content-Type.\n* :ref:`binary-objects` which have their own method for setting result\n  Content-Type.",
    "short": "Set Content-Type of a result returned to a client.",
    "signature": "splash:set_result_content_type(content_type)",
    "returns": "nil.",
    "async": "no.",
    "details": "If a table is returned by \"main\" function then\n``splash:set_result_content_type`` has no effect: Content-Type of the result\nis set to ``application/json``.\n\nThis function **does not** set Content-Type header for requests\ninitiated by :ref:`splash-go`; this function is for setting Content-Type\nheader of a result.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:set_result_content_type(\"text/xml\")\n         return [[\n            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <note>\n                <to>Tove</to>\n                <from>Jani</from>\n                <heading>Reminder</heading>\n                <body>Don't forget me this weekend!</body>\n            </note>\n         ]]\n     end\n\nSee also:\n\n* :ref:`splash-set-result-header` which allows to set any custom\n  response header, not only Content-Type.\n* :ref:`binary-objects` which have their own method for setting result\n  Content-Type.",
    "params": "* content_type - a string with Content-Type header value."
  },
  "splash:set_result_header": {
    "name": "set_result_header",
    "header": "splash:set_result_header",
    "content": "Set header of result response returned to splash client.\n\n**Signature:** ``splash:set_result_header(name, value)``\n\n**Parameters:**\n\n* name of response header\n* value of response header\n\n**Returns:** nil.\n\n**Async:** no.\n\nThis function **does not** set HTTP headers for responses\nreturned by :ref:`splash-go` or requests initiated by :ref:`splash-go`;\nthis function is for setting headers of splash response sent to client.\n\nExample 1, set 'foo=bar' header:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:set_result_header(\"foo\", \"bar\")\n         return \"hello\"\n     end\n\nExample 2, measure the time needed to build PNG screenshot and return it\nresult in an HTTP header:\n\n.. code-block:: lua\n\n     function main(splash)\n\n         -- this function measures the time code takes to execute and returns\n         -- it in an HTTP header\n         function timeit(header_name, func)\n             local start_time = splash:get_perf_stats().walltime\n             local result = func()  -- it won't work for multiple returned values!\n             local end_time = splash:get_perf_stats().walltime\n             splash:set_result_header(header_name, tostring(end_time - start_time))\n             return result\n         end\n\n         -- rendering script\n         assert(splash:go(splash.args.url))\n         local screenshot = timeit(\"X-Render-Time\", function()\n            return splash:png()\n         end)\n         splash:set_result_content_type(\"image/png\")\n         return screenshot\n     end\n\nSee also: :ref:`splash-set-result-status-code`,\n:ref:`splash-set-result-content-type`.",
    "short": "Set header of result response returned to splash client.",
    "signature": "splash:set_result_header(name, value)",
    "returns": "nil.",
    "async": "no.",
    "details": "This function **does not** set HTTP headers for responses\nreturned by :ref:`splash-go` or requests initiated by :ref:`splash-go`;\nthis function is for setting headers of splash response sent to client.\n\nExample 1, set 'foo=bar' header:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:set_result_header(\"foo\", \"bar\")\n         return \"hello\"\n     end\n\nExample 2, measure the time needed to build PNG screenshot and return it\nresult in an HTTP header:\n\n.. code-block:: lua\n\n     function main(splash)\n\n         -- this function measures the time code takes to execute and returns\n         -- it in an HTTP header\n         function timeit(header_name, func)\n             local start_time = splash:get_perf_stats().walltime\n             local result = func()  -- it won't work for multiple returned values!\n             local end_time = splash:get_perf_stats().walltime\n             splash:set_result_header(header_name, tostring(end_time - start_time))\n             return result\n         end\n\n         -- rendering script\n         assert(splash:go(splash.args.url))\n         local screenshot = timeit(\"X-Render-Time\", function()\n            return splash:png()\n         end)\n         splash:set_result_content_type(\"image/png\")\n         return screenshot\n     end\n\nSee also: :ref:`splash-set-result-status-code`,\n:ref:`splash-set-result-content-type`.",
    "params": "* name of response header\n* value of response header"
  },
  "splash:get_viewport_size": {
    "name": "get_viewport_size",
    "header": "splash:get_viewport_size",
    "content": "Get the browser viewport size.\n\n**Signature:** ``width, height = splash:get_viewport_size()``\n\n**Returns:** two numbers: width and height of the viewport in pixels.\n\n**Async:** no.",
    "short": "Get the browser viewport size.",
    "signature": "width, height = splash:get_viewport_size()",
    "returns": "two numbers: width and height of the viewport in pixels.",
    "async": "no.",
    "details": "",
    "params": null
  },
  "splash:set_viewport_size": {
    "name": "set_viewport_size",
    "header": "splash:set_viewport_size",
    "content": "Set the browser viewport size.\n\n**Signature:** ``splash:set_viewport_size(width, height)``\n\n**Parameters:**\n\n* width - integer, requested viewport width in pixels;\n* height - integer, requested viewport height in pixels.\n\n**Returns:** nil.\n\n**Async:** no.\n\nThis will change the size of the visible area and subsequent rendering\ncommands, e.g., :ref:`splash-png`, will produce an image with the specified\nsize.\n\n:ref:`splash-png` uses the viewport size.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:set_viewport_size(1980, 1020)\n         assert(splash:go(\"http://example.com\"))\n         return {png=splash:png()}\n     end\n\n.. note::\n\n   This will relayout all document elements and affect geometry variables, such\n   as ``window.innerWidth`` and ``window.innerHeight``.  However\n   ``window.onresize`` event callback will only be invoked during the next\n   asynchronous operation and :ref:`splash-png` is notably synchronous, so if\n   you have resized a page and want it to react accordingly before taking the\n   screenshot, use :ref:`splash-wait`.",
    "short": "Set the browser viewport size.",
    "signature": "splash:set_viewport_size(width, height)",
    "returns": "nil.",
    "async": "no.",
    "details": "This will change the size of the visible area and subsequent rendering\ncommands, e.g., :ref:`splash-png`, will produce an image with the specified\nsize.\n\n:ref:`splash-png` uses the viewport size.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         splash:set_viewport_size(1980, 1020)\n         assert(splash:go(\"http://example.com\"))\n         return {png=splash:png()}\n     end\n\n.. note::\n\n   This will relayout all document elements and affect geometry variables, such\n   as ``window.innerWidth`` and ``window.innerHeight``.  However\n   ``window.onresize`` event callback will only be invoked during the next\n   asynchronous operation and :ref:`splash-png` is notably synchronous, so if\n   you have resized a page and want it to react accordingly before taking the\n   screenshot, use :ref:`splash-wait`.",
    "params": "* width - integer, requested viewport width in pixels;\n* height - integer, requested viewport height in pixels."
  },
  "splash:set_viewport_full": {
    "name": "set_viewport_full",
    "header": "splash:set_viewport_full",
    "content": "Resize browser viewport to fit the whole page.\n\n**Signature:** ``width, height = splash:set_viewport_full()``\n\n**Returns:** two numbers: width and height the viewport is set to, in pixels.\n\n**Async:** no.\n\n``splash:set_viewport_full`` should be called only after page is loaded, and\nsome time passed after that (use :ref:`splash-wait`). This is an unfortunate\nrestriction, but it seems that this is the only way to make automatic resizing\nwork reliably.\n\nSee :ref:`splash-set-viewport-size` for a note about interaction with JS.\n\n:ref:`splash-png` uses the viewport size.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(\"http://example.com\"))\n         assert(splash:wait(0.5))\n         splash:set_viewport_full()\n         return {png=splash:png()}\n     end",
    "short": "Resize browser viewport to fit the whole page.",
    "signature": "width, height = splash:set_viewport_full()",
    "returns": "two numbers: width and height the viewport is set to, in pixels.",
    "async": "no.",
    "details": "``splash:set_viewport_full`` should be called only after page is loaded, and\nsome time passed after that (use :ref:`splash-wait`). This is an unfortunate\nrestriction, but it seems that this is the only way to make automatic resizing\nwork reliably.\n\nSee :ref:`splash-set-viewport-size` for a note about interaction with JS.\n\n:ref:`splash-png` uses the viewport size.\n\nExample:\n\n.. code-block:: lua\n\n     function main(splash)\n         assert(splash:go(\"http://example.com\"))\n         assert(splash:wait(0.5))\n         splash:set_viewport_full()\n         return {png=splash:png()}\n     end",
    "params": null
  },
  "splash:set_user_agent": {
    "name": "set_user_agent",
    "header": "splash:set_user_agent",
    "content": "Overwrite the User-Agent header for all further requests.\n\n**Signature:** ``splash:set_user_agent(value)``\n\n**Parameters:**\n\n* value - string, a value of User-Agent HTTP header.\n\n**Returns:** nil.\n\n**Async:** no.",
    "short": "Overwrite the User-Agent header for all further requests.",
    "signature": "splash:set_user_agent(value)",
    "returns": "nil.",
    "async": "no.",
    "details": "",
    "params": "* value - string, a value of User-Agent HTTP header."
  },
  "splash:set_custom_headers": {
    "name": "set_custom_headers",
    "header": "splash:set_custom_headers",
    "content": "Set custom HTTP headers to send with each request.\n\n**Signature:** ``splash:set_custom_headers(headers)``\n\n**Parameters:**\n\n* headers - a Lua table with HTTP headers.\n\n**Returns:** nil.\n\n**Async:** no.\n\nHeaders are merged with WebKit default headers, overwriting WebKit values\nin case of conflicts.\n\nWhen ``headers`` argument of :ref:`splash-go` is used headers set with\n``splash:set_custom_headers`` are not applied to the initial request:\nvalues are not merged, ``headers`` argument of :ref:`splash-go` has\nhigher priority.\n\nExample:\n\n.. code-block:: lua\n\n     splash:set_custom_headers({\n        [\"Header-1\"] = \"Value 1\",\n        [\"Header-2\"] = \"Value 2\",\n     })\n\n.. note::\n\n    Named arguments are not supported for this function.\n\nSee also: :ref:`splash-on-request`.",
    "short": "Set custom HTTP headers to send with each request.",
    "signature": "splash:set_custom_headers(headers)",
    "returns": "nil.",
    "async": "no.",
    "details": "Headers are merged with WebKit default headers, overwriting WebKit values\nin case of conflicts.\n\nWhen ``headers`` argument of :ref:`splash-go` is used headers set with\n``splash:set_custom_headers`` are not applied to the initial request:\nvalues are not merged, ``headers`` argument of :ref:`splash-go` has\nhigher priority.\n\nExample:\n\n.. code-block:: lua\n\n     splash:set_custom_headers({\n        [\"Header-1\"] = \"Value 1\",\n        [\"Header-2\"] = \"Value 2\",\n     })\n\n.. note::\n\n    Named arguments are not supported for this function.\n\nSee also: :ref:`splash-on-request`.",
    "params": "* headers - a Lua table with HTTP headers."
  },
  "splash:get_perf_stats": {
    "name": "get_perf_stats",
    "header": "splash:get_perf_stats",
    "content": "Return performance-related statistics.\n\n**Signature:** ``stats = splash:get_perf_stats()``\n\n**Returns:** a table that can be useful for performance analysis.\n\n**Async:** no.\n\nAs of now, this table contains:\n\n* ``walltime`` - (float) number of seconds since epoch, analog of ``os.clock``\n* ``cputime`` - (float) number of cpu seconds consumed by splash process\n* ``maxrss`` - (int) high water mark number of bytes of RAM consumed by splash\n  process",
    "short": "Return performance-related statistics.",
    "signature": "stats = splash:get_perf_stats()",
    "returns": "a table that can be useful for performance analysis.",
    "async": "no.",
    "details": "As of now, this table contains:\n\n* ``walltime`` - (float) number of seconds since epoch, analog of ``os.clock``\n* ``cputime`` - (float) number of cpu seconds consumed by splash process\n* ``maxrss`` - (int) high water mark number of bytes of RAM consumed by splash\n  process",
    "params": null
  },
  "splash:on_request": {
    "name": "on_request",
    "header": "splash:on_request",
    "content": "Register a function to be called before each HTTP request.\n\n**Signature:** ``splash:on_request(callback)``\n\n**Parameters:**\n\n* callback - Lua function to call before each HTTP request.\n\n**Returns:** nil.\n\n**Async:** no.\n\n:ref:`splash-on-request` callback receives a single ``request`` argument\n(a :ref:`splash-request`).\n\nTo get information about a request use request\n:ref:`attributes <splash-request-attributes>`;\nto change or drop the request before sending use request\n:ref:`methods <splash-request-methods>`;\n\nA callback passed to :ref:`splash-on-request` can't call Splash\nasync methods like :ref:`splash-wait` or :ref:`splash-go`.\n\nExample 1 - log all URLs requested using :ref:`splash-request-url` attribute:\n\ntreat = require(\"treat\")\n\nfunction main(splash, args)\n  local urls = {}\n  splash:on_request(function(request)\n    table.insert(urls, request.url)\n  end)\n\n  assert(splash:go(splash.args.url))\n  return treat.as_array(urls)\nend\nExample 2 - to log full request information use :ref:`splash-request-info`\nattribute; don't store ``request`` objects directly:\n\n.. code-block:: lua\n\n    treat = require(\"treat\")\n    function main(splash)\n        local entries = treat.as_array({})\n        splash:on_request(function(request)\n            table.insert(entries, request.info)\n        end)\n        assert(splash:go(splash.args.url))\n        return entries\n    end\n\nExample 3 - drop all requests to resources containing \".css\" in their URLs\n(see :ref:`splash-request-abort`):\n\n.. code-block:: lua\n\n    splash:on_request(function(request)\n        if string.find(request.url, \".css\") ~= nil then\n            request.abort()\n        end\n    end)\n\nExample 4 - replace a resource\n(see :ref:`splash-request-set-url`):\n\n.. code-block:: lua\n\n    splash:on_request(function(request)\n        if request.url == 'http://example.com/script.js' then\n            request:set_url('http://mydomain.com/myscript.js')\n        end\n    end)\n\nExample 5 - set a custom proxy server, with credentials passed in an HTTP\nrequest to Splash (see :ref:`splash-request-set-proxy`):\n\n.. code-block:: lua\n\n    splash:on_request(function(request)\n        request:set_proxy{\n            host = \"0.0.0.0\",\n            port = 8990,\n            username = splash.args.username,\n            password = splash.args.password,\n        }\n    end)\n\nExample 6 - discard requests which take longer than 5 seconds to complete,\nbut allow up to 15 seconds for the first request\n(see :ref:`splash-request-set-timeout`):\n\n.. code-block:: lua\n\n    local first = true\n    splash.resource_timeout = 5\n    splash:on_request(function(request)\n        if first then\n            request:set_timeout(15.0)\n            first = false\n        end\n    end)\n\n.. note::\n\n    :ref:`splash-on-request` doesn't support named arguments.\n\nSee also: :ref:`splash-on-response`, :ref:`splash-on-response-headers`,\n:ref:`splash-on-request-reset`, :ref:`lib-treat`, :ref:`splash-request`.",
    "short": "Register a function to be called before each HTTP request.",
    "signature": "splash:on_request(callback)",
    "returns": "nil.",
    "async": "no.",
    "details": ":ref:`splash-on-request` callback receives a single ``request`` argument\n(a :ref:`splash-request`).\n\nTo get information about a request use request\n:ref:`attributes <splash-request-attributes>`;\nto change or drop the request before sending use request\n:ref:`methods <splash-request-methods>`;\n\nA callback passed to :ref:`splash-on-request` can't call Splash\nasync methods like :ref:`splash-wait` or :ref:`splash-go`.\n\nExample 1 - log all URLs requested using :ref:`splash-request-url` attribute:\n\ntreat = require(\"treat\")\n\nfunction main(splash, args)\n  local urls = {}\n  splash:on_request(function(request)\n    table.insert(urls, request.url)\n  end)\n\n  assert(splash:go(splash.args.url))\n  return treat.as_array(urls)\nend\nExample 2 - to log full request information use :ref:`splash-request-info`\nattribute; don't store ``request`` objects directly:\n\n.. code-block:: lua\n\n    treat = require(\"treat\")\n    function main(splash)\n        local entries = treat.as_array({})\n        splash:on_request(function(request)\n            table.insert(entries, request.info)\n        end)\n        assert(splash:go(splash.args.url))\n        return entries\n    end\n\nExample 3 - drop all requests to resources containing \".css\" in their URLs\n(see :ref:`splash-request-abort`):\n\n.. code-block:: lua\n\n    splash:on_request(function(request)\n        if string.find(request.url, \".css\") ~= nil then\n            request.abort()\n        end\n    end)\n\nExample 4 - replace a resource\n(see :ref:`splash-request-set-url`):\n\n.. code-block:: lua\n\n    splash:on_request(function(request)\n        if request.url == 'http://example.com/script.js' then\n            request:set_url('http://mydomain.com/myscript.js')\n        end\n    end)\n\nExample 5 - set a custom proxy server, with credentials passed in an HTTP\nrequest to Splash (see :ref:`splash-request-set-proxy`):\n\n.. code-block:: lua\n\n    splash:on_request(function(request)\n        request:set_proxy{\n            host = \"0.0.0.0\",\n            port = 8990,\n            username = splash.args.username,\n            password = splash.args.password,\n        }\n    end)\n\nExample 6 - discard requests which take longer than 5 seconds to complete,\nbut allow up to 15 seconds for the first request\n(see :ref:`splash-request-set-timeout`):\n\n.. code-block:: lua\n\n    local first = true\n    splash.resource_timeout = 5\n    splash:on_request(function(request)\n        if first then\n            request:set_timeout(15.0)\n            first = false\n        end\n    end)\n\n.. note::\n\n    :ref:`splash-on-request` doesn't support named arguments.\n\nSee also: :ref:`splash-on-response`, :ref:`splash-on-response-headers`,\n:ref:`splash-on-request-reset`, :ref:`lib-treat`, :ref:`splash-request`.",
    "params": "* callback - Lua function to call before each HTTP request."
  },
  "splash:on_response_headers": {
    "name": "on_response_headers",
    "header": "splash:on_response_headers",
    "content": "Register a function to be called after response headers are received, before\nresponse body is read.\n\n**Signature:** ``splash:on_response_headers(callback)``\n\n**Parameters:**\n\n* callback - Lua function to call for each response after\n  response headers are received.\n\n**Returns:** nil.\n\n**Async:** no.\n\n:ref:`splash-on-response-headers` callback receives a single ``response``\nargument (a :ref:`splash-response`).\n\n:ref:`splash-response-body` is not available in\na :ref:`splash-on-response-headers` callback because response body is not\nread yet. That's the point of :ref:`splash-on-response-headers` method: you can\nabort reading of the response body using :ref:`splash-response-abort` method.\n\n\n.. XXX: should we allow to access response attributes (not methods)\n   outside a callback?\n\nA callback passed to :ref:`splash-on-response-headers` can't call Splash\nasync methods like :ref:`splash-wait` or :ref:`splash-go`. ``response`` object\nis deleted after exiting from a callback, so you cannot use\nit outside a callback.\n\nExample 1 - log content-type headers of all responses received while rendering\n\n.. code-block:: lua\n\n    function main(splash)\n        local all_headers = {}\n        splash:on_response_headers(function(response)\n            local content_type = response.headers[\"Content-Type\"]\n            all_headers[response.url] = content_type\n        end)\n        assert(splash:go(splash.args.url))\n        return all_headers\n    end\n\nExample 2 - abort reading body of all responses with content type ``text/css``\n\nfunction main(splash, args)\n  splash:on_response_headers(function(response)\n    local ct = response.headers[\"Content-Type\"]\n    if ct == \"text/css\" then\n      response.abort()\n    end\n  end)\n\n  assert(splash:go(args.url))\n  return {\n    png=splash:png(),\n    har=splash:har()\n  }\nend\nExample 3 - extract all cookies set by website without downloading\nresponse bodies\n\n.. code-block:: lua\n\n    function main(splash)\n        local cookies = \"\"\n        splash:on_response_headers(function(response)\n            local response_cookies = response.headers[\"Set-cookie\"]\n            cookies = cookies .. \";\" .. response_cookies\n            response.abort()\n        end)\n        assert(splash:go(splash.args.url))\n        return cookies\n    end\n\n.. note::\n\n    :ref:`splash-on-response-headers` doesn't support named arguments.\n\nSee also: :ref:`splash-on-request`, :ref:`splash-on-response`,\n:ref:`splash-on-response-headers-reset`, :ref:`splash-response`.",
    "short": "Register a function to be called after response headers are received, before\nresponse body is read.",
    "signature": "splash:on_response_headers(callback)",
    "returns": "nil.",
    "async": "no.",
    "details": ":ref:`splash-on-response-headers` callback receives a single ``response``\nargument (a :ref:`splash-response`).\n\n:ref:`splash-response-body` is not available in\na :ref:`splash-on-response-headers` callback because response body is not\nread yet. That's the point of :ref:`splash-on-response-headers` method: you can\nabort reading of the response body using :ref:`splash-response-abort` method.\n\n\n.. XXX: should we allow to access response attributes (not methods)\n   outside a callback?\n\nA callback passed to :ref:`splash-on-response-headers` can't call Splash\nasync methods like :ref:`splash-wait` or :ref:`splash-go`. ``response`` object\nis deleted after exiting from a callback, so you cannot use\nit outside a callback.\n\nExample 1 - log content-type headers of all responses received while rendering\n\n.. code-block:: lua\n\n    function main(splash)\n        local all_headers = {}\n        splash:on_response_headers(function(response)\n            local content_type = response.headers[\"Content-Type\"]\n            all_headers[response.url] = content_type\n        end)\n        assert(splash:go(splash.args.url))\n        return all_headers\n    end\n\nExample 2 - abort reading body of all responses with content type ``text/css``\n\nfunction main(splash, args)\n  splash:on_response_headers(function(response)\n    local ct = response.headers[\"Content-Type\"]\n    if ct == \"text/css\" then\n      response.abort()\n    end\n  end)\n\n  assert(splash:go(args.url))\n  return {\n    png=splash:png(),\n    har=splash:har()\n  }\nend\nExample 3 - extract all cookies set by website without downloading\nresponse bodies\n\n.. code-block:: lua\n\n    function main(splash)\n        local cookies = \"\"\n        splash:on_response_headers(function(response)\n            local response_cookies = response.headers[\"Set-cookie\"]\n            cookies = cookies .. \";\" .. response_cookies\n            response.abort()\n        end)\n        assert(splash:go(splash.args.url))\n        return cookies\n    end\n\n.. note::\n\n    :ref:`splash-on-response-headers` doesn't support named arguments.\n\nSee also: :ref:`splash-on-request`, :ref:`splash-on-response`,\n:ref:`splash-on-response-headers-reset`, :ref:`splash-response`.",
    "params": "* callback - Lua function to call for each response after\n  response headers are received."
  },
  "splash:on_response": {
    "name": "on_response",
    "header": "splash:on_response",
    "content": "Register a function to be called after response is downloaded.\n\n**Signature:** ``splash:on_response(callback)``\n\n**Parameters:**\n\n* callback - Lua function to call for each response after it is downloaded.\n\n**Returns:** nil.\n\n**Async:** no.\n\n:ref:`splash-on-response` callback receives a single ``response`` argument\n(a :ref:`splash-response`).\n\nBy default, this ``response`` object doesn't have :ref:`splash-response-body`\nattribute. To enable it, use :ref:`splash-response-body-enabled` option\nor :ref:`splash-request-enable-response-body` method.\n\n.. note::\n\n    :ref:`splash-on-response` doesn't support named arguments.\n\nSee also: :ref:`splash-on-request`, :ref:`splash-on-response-headers`,\n:ref:`splash-on-response-reset`, :ref:`splash-response`,\n:ref:`splash-response-body-enabled`, :ref:`splash-request-enable-response-body`.",
    "short": "Register a function to be called after response is downloaded.",
    "signature": "splash:on_response(callback)",
    "returns": "nil.",
    "async": "no.",
    "details": ":ref:`splash-on-response` callback receives a single ``response`` argument\n(a :ref:`splash-response`).\n\nBy default, this ``response`` object doesn't have :ref:`splash-response-body`\nattribute. To enable it, use :ref:`splash-response-body-enabled` option\nor :ref:`splash-request-enable-response-body` method.\n\n.. note::\n\n    :ref:`splash-on-response` doesn't support named arguments.\n\nSee also: :ref:`splash-on-request`, :ref:`splash-on-response-headers`,\n:ref:`splash-on-response-reset`, :ref:`splash-response`,\n:ref:`splash-response-body-enabled`, :ref:`splash-request-enable-response-body`.",
    "params": "* callback - Lua function to call for each response after it is downloaded."
  },
  "splash:on_request_reset": {
    "name": "on_request_reset",
    "header": "splash:on_request_reset",
    "content": "Remove all callbacks registered by :ref:`splash-on-request`.\n\n**Signature:** ``splash:on_request_reset()``\n\n**Returns:** nil\n\n**Async:** no.",
    "short": "Remove all callbacks registered by :ref:`splash-on-request`.",
    "signature": "splash:on_request_reset()",
    "returns": "nil",
    "async": "no.",
    "details": "",
    "params": null
  },
  "splash:on_response_headers_reset": {
    "name": "on_response_headers_reset",
    "header": "splash:on_response_headers_reset",
    "content": "Remove all callbacks registered by :ref:`splash-on-response-headers`.\n\n**Signature:** ``splash:on_response_headers_reset()``\n\n**Returns:** nil\n\n**Async:** no.",
    "short": "Remove all callbacks registered by :ref:`splash-on-response-headers`.",
    "signature": "splash:on_response_headers_reset()",
    "returns": "nil",
    "async": "no.",
    "details": "",
    "params": null
  },
  "splash:on_response_reset": {
    "name": "on_response_reset",
    "header": "splash:on_response_reset",
    "content": "Remove all callbacks registered by :ref:`splash-on-response`.\n\n**Signature:** ``splash:on_response_reset()``\n\n**Returns:** nil\n\n**Async:** no.",
    "short": "Remove all callbacks registered by :ref:`splash-on-response`.",
    "signature": "splash:on_response_reset()",
    "returns": "nil",
    "async": "no.",
    "details": "",
    "params": null
  },
  "splash:get_version": {
    "name": "get_version",
    "header": "splash:get_version",
    "content": "Get Splash major and minor version.\n\n**Signature:** ``version_info = splash:get_version()``\n\n**Returns:** A table with version information.\n\n**Async:** no.\n\nAs of now, this table contains:\n\n* ``splash`` - (string) Splash version\n* ``major`` - (int) Splash major version\n* ``minor`` - (int) Splash minor version\n* ``python`` - (string) Python version\n* ``qt`` - (string) Qt version\n* ``pyqt`` - (string) PyQt version\n* ``webkit`` - (string) WebKit version\n* ``sip`` - (string) SIP version\n* ``twisted`` - (string) Twisted version\n\nExample:\n\n.. code-block:: lua\n\n    function main(splash)\n         local version = splash:get_version()\n         if version.major < 2 and version.minor < 8 then\n             error(\"Splash 1.8 or newer required\")\n         end\n     end",
    "short": "Get Splash major and minor version.",
    "signature": "version_info = splash:get_version()",
    "returns": "A table with version information.",
    "async": "no.",
    "details": "As of now, this table contains:\n\n* ``splash`` - (string) Splash version\n* ``major`` - (int) Splash major version\n* ``minor`` - (int) Splash minor version\n* ``python`` - (string) Python version\n* ``qt`` - (string) Qt version\n* ``pyqt`` - (string) PyQt version\n* ``webkit`` - (string) WebKit version\n* ``sip`` - (string) SIP version\n* ``twisted`` - (string) Twisted version\n\nExample:\n\n.. code-block:: lua\n\n    function main(splash)\n         local version = splash:get_version()\n         if version.major < 2 and version.minor < 8 then\n             error(\"Splash 1.8 or newer required\")\n         end\n     end",
    "params": null
  },
  "splash:mouse_click": {
    "name": "mouse_click",
    "header": "splash:mouse_click",
    "content": "Trigger mouse click event in web page.\n\n**Signature:** ``splash:mouse_click(x, y)``\n\n**Parameters:**\n\n* x - number with x position of element to be clicked\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element to be clicked\n  (distance from the top, relative to the current viewport)\n\n**Returns:** nil\n\n**Async:** no.\n\nCoordinates for mouse events must be relative to viewport.\n\nIf you want to click on element an easy way is to use :ref:`splash-select`\nwith :ref:`splash-element-mouse-click`:\n\n.. code-block:: lua\n\n    local button = splash:select('button')\n    button:mouse_click()\n\nYou also can implement it using :ref:`splash-mouse-click`;\nuse JavaScript getClientRects_ to get coordinates of html element:\n\n.. code-block:: lua\n\n    -- Get button element dimensions with javascript and perform mouse click.\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        local get_dimensions = splash:jsfunc([[\n            function () {\n                var rect = document.getElementById('button').getClientRects()[0];\n                return {\"x\": rect.left, \"y\": rect.top}\n            }\n        ]])\n        splash:set_viewport_full()\n        splash:wait(0.1)\n        local dimensions = get_dimensions()\n        -- FIXME: button must be inside a viewport\n        splash:mouse_click(dimensions.x, dimensions.y)\n\n        -- Wait split second to allow event to propagate.\n        splash:wait(0.1)\n        return splash:html()\n    end\n\n.. _getClientRects: https://developer.mozilla.org/en/docs/Web/API/Element/getClientRects\n\nUnlike :ref:`splash-element-mouse-click`, :ref:`splash-mouse-click` is not\nasync. Mouse events are not propagated immediately, to see consequences\nof click reflected in page source you must call :ref:`splash-wait` if you\nuse :ref:`splash-mouse-click`.\n\nElement on which action is performed must be inside viewport\n(must be visible to the user). If element is outside viewport and\nuser needs to scroll to see it, you must either scroll to the element\n(using JavaScript, :ref:`splash-scroll-position` or e.g.\n``element:scrollIntoViewIfNeeded()``) or set viewport to full with\n:ref:`splash-set-viewport-full`.\n\n.. note::\n\n    :ref:`splash-element-mouse-click` scrolls automatically, unlike\n    :ref:`splash-mouse-click`.\n\nUnder the hood :ref:`splash-mouse-click` performs :ref:`splash-mouse-press`\nfollowed by :ref:`splash-mouse-release`.\n\nAt the moment only left click is supported.\n\nSee also: :ref:`splash-element-mouse-click`, :ref:`splash-mouse-press`,\n:ref:`splash-mouse-release`, :ref:`splash-mouse-hover`,\n:ref:`splash-scroll-position`.",
    "short": "Trigger mouse click event in web page.",
    "signature": "splash:mouse_click(x, y)",
    "returns": "nil",
    "async": "no.",
    "details": "Coordinates for mouse events must be relative to viewport.\n\nIf you want to click on element an easy way is to use :ref:`splash-select`\nwith :ref:`splash-element-mouse-click`:\n\n.. code-block:: lua\n\n    local button = splash:select('button')\n    button:mouse_click()\n\nYou also can implement it using :ref:`splash-mouse-click`;\nuse JavaScript getClientRects_ to get coordinates of html element:\n\n.. code-block:: lua\n\n    -- Get button element dimensions with javascript and perform mouse click.\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        local get_dimensions = splash:jsfunc([[\n            function () {\n                var rect = document.getElementById('button').getClientRects()[0];\n                return {\"x\": rect.left, \"y\": rect.top}\n            }\n        ]])\n        splash:set_viewport_full()\n        splash:wait(0.1)\n        local dimensions = get_dimensions()\n        -- FIXME: button must be inside a viewport\n        splash:mouse_click(dimensions.x, dimensions.y)\n\n        -- Wait split second to allow event to propagate.\n        splash:wait(0.1)\n        return splash:html()\n    end\n\n.. _getClientRects: https://developer.mozilla.org/en/docs/Web/API/Element/getClientRects\n\nUnlike :ref:`splash-element-mouse-click`, :ref:`splash-mouse-click` is not\nasync. Mouse events are not propagated immediately, to see consequences\nof click reflected in page source you must call :ref:`splash-wait` if you\nuse :ref:`splash-mouse-click`.\n\nElement on which action is performed must be inside viewport\n(must be visible to the user). If element is outside viewport and\nuser needs to scroll to see it, you must either scroll to the element\n(using JavaScript, :ref:`splash-scroll-position` or e.g.\n``element:scrollIntoViewIfNeeded()``) or set viewport to full with\n:ref:`splash-set-viewport-full`.\n\n.. note::\n\n    :ref:`splash-element-mouse-click` scrolls automatically, unlike\n    :ref:`splash-mouse-click`.\n\nUnder the hood :ref:`splash-mouse-click` performs :ref:`splash-mouse-press`\nfollowed by :ref:`splash-mouse-release`.\n\nAt the moment only left click is supported.\n\nSee also: :ref:`splash-element-mouse-click`, :ref:`splash-mouse-press`,\n:ref:`splash-mouse-release`, :ref:`splash-mouse-hover`,\n:ref:`splash-scroll-position`.",
    "params": "* x - number with x position of element to be clicked\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element to be clicked\n  (distance from the top, relative to the current viewport)"
  },
  "splash:mouse_hover": {
    "name": "mouse_hover",
    "header": "splash:mouse_hover",
    "content": "Trigger mouse hover (JavaScript mouseover) event in web page.\n\n**Signature:** ``splash:mouse_hover(x, y)``\n\n**Parameters:**\n\n* x - number with x position of element to be hovered on\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element to be hovered on\n  (distance from the top, relative to the current viewport)\n\n**Returns:** nil\n\n**Async:** no.\n\nSee notes about mouse events in :ref:`splash-mouse-click`.\n\nSee also: :ref:`splash-element-mouse-hover`.",
    "short": "Trigger mouse hover (JavaScript mouseover) event in web page.",
    "signature": "splash:mouse_hover(x, y)",
    "returns": "nil",
    "async": "no.",
    "details": "See notes about mouse events in :ref:`splash-mouse-click`.\n\nSee also: :ref:`splash-element-mouse-hover`.",
    "params": "* x - number with x position of element to be hovered on\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element to be hovered on\n  (distance from the top, relative to the current viewport)"
  },
  "splash:mouse_press": {
    "name": "mouse_press",
    "header": "splash:mouse_press",
    "content": "Trigger mouse press event in web page.\n\n**Signature:** ``splash:mouse_press(x, y)``\n\n**Parameters:**\n\n* x - number with x position of element over which mouse button is pressed\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element over which mouse button is pressed\n  (distance from the top, relative to the current viewport)\n\n**Returns:** nil\n\n**Async:** no.\n\nSee notes about mouse events in :ref:`splash-mouse-click`.",
    "short": "Trigger mouse press event in web page.",
    "signature": "splash:mouse_press(x, y)",
    "returns": "nil",
    "async": "no.",
    "details": "See notes about mouse events in :ref:`splash-mouse-click`.",
    "params": "* x - number with x position of element over which mouse button is pressed\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element over which mouse button is pressed\n  (distance from the top, relative to the current viewport)"
  },
  "splash:mouse_release": {
    "name": "mouse_release",
    "header": "splash:mouse_release",
    "content": "Trigger mouse release event in web page.\n\n**Signature:** ``splash:mouse_release(x, y)``\n\n**Parameters:**\n\n* x - number with x position of element over which mouse button is released\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element over which mouse button is released\n  (distance from the top, relative to the current viewport)\n\n**Returns:** nil\n\n**Async:** no.\n\nSee notes about mouse events in :ref:`splash-mouse-click`.",
    "short": "Trigger mouse release event in web page.",
    "signature": "splash:mouse_release(x, y)",
    "returns": "nil",
    "async": "no.",
    "details": "See notes about mouse events in :ref:`splash-mouse-click`.",
    "params": "* x - number with x position of element over which mouse button is released\n  (distance from the left, relative to the current viewport)\n* y - number with y position of element over which mouse button is released\n  (distance from the top, relative to the current viewport)"
  },
  "splash:with_timeout": {
    "name": "with_timeout",
    "header": "splash:with_timeout",
    "content": "Run the function with the allowed timeout\n\n**Signature:** ``ok, result = splash:with_timeout(func, timeout)``\n\n**Parameters:**\n\n* func - the function to run\n* timeout - timeout, in seconds\n\n**Returns:** ``ok, result`` pair. If ``ok`` is not ``true`` then error\nhappened during the function call or the timeout expired; ``result``\nprovides an information about error type. If ``result`` is equal to\n``timeout`` then the specified timeout period elapsed.\nOtherwise, if ``ok`` is ``true`` then ``result`` contains the result of\nthe executed function. If your function returns several values, they\nwill be assigned to the next variables to ``result``.\n\n**Async:** yes.\n\nExample 1:\n\nfunction main(splash, args)\n  local ok, result = splash:with_timeout(function()\n    -- try commenting out splash:wait(3)\n    splash:wait(3)\n    assert(splash:go(args.url))\n  end, 2)\n\n  if not ok then\n    if result == \"timeout_over\" then\n      return \"Cannot navigate to the url within 2 seconds\"\n    else\n      return result\n    end\n  end\n  return \"Navigated to the url within 2 seconds\"\nend\nExample 2 - the function returns several values\n\n.. code-block:: lua\n\n    function main(splash)\n        local ok, result1, result2, result3 = splash:with_timeout(function()\n            splash:wait(0.5)\n            return 1, 2, 3\n        end, 1)\n\n        return result1, result2, result3\n    end\n\nNote that if the specified timeout period elapsed Splash will try to\ninterrupt the running function. However, Splash scripts are executed\nin `cooperative multitasking`_ manner and because of that sometimes\nSplash won't be able to stop your running function upon timeout expiration.\nIn two words, cooperative multitasking means that the managing program\n(in our example, it is Splash scripting engine) won't stop the running\nfunction if it doesn't *ask* for that. In Splash scripting the running\nfunction can be interrupted only if some *async* operation was called.\nOn the contrary, non of the *sync* operations can be interrupted.\n\n.. note::\n\n    Splash scripts are executing in `cooperative multitasking`_ manner.\n    You should be careful while running sync functions.\n\nLet's see the difference in examples.\n\nExample 3:\n\n.. code-block:: lua\n\n    function main(splash)\n        local ok, result = splash:with_timeout(function()\n            splash:go(splash.args.url) -- during this operation the current function can be stopped\n            splash:evaljs(long_js_operation) -- during JS function evaluation the function cannot be stopped\n            local png = splash:png() -- sync operation and during it the function cannot be stopped\n            return png\n        end, 0.1)\n\n        return result\n    end\n.. _cooperative multitasking: https://en.wikipedia.org/wiki/Cooperative_multitasking",
    "short": "Run the function with the allowed timeout",
    "signature": "ok, result = splash:with_timeout(func, timeout)",
    "returns": "``ok, result`` pair. If ``ok`` is not ``true`` then error\nhappened during the function call or the timeout expired; ``result``\nprovides an information about error type. If ``result`` is equal to\n``timeout`` then the specified timeout period elapsed.\nOtherwise, if ``ok`` is ``true`` then ``result`` contains the result of\nthe executed function. If your function returns several values, they\nwill be assigned to the next variables to ``result``.",
    "async": "yes.",
    "details": "Example 1:\n\nfunction main(splash, args)\n  local ok, result = splash:with_timeout(function()\n    -- try commenting out splash:wait(3)\n    splash:wait(3)\n    assert(splash:go(args.url))\n  end, 2)\n\n  if not ok then\n    if result == \"timeout_over\" then\n      return \"Cannot navigate to the url within 2 seconds\"\n    else\n      return result\n    end\n  end\n  return \"Navigated to the url within 2 seconds\"\nend\nExample 2 - the function returns several values\n\n.. code-block:: lua\n\n    function main(splash)\n        local ok, result1, result2, result3 = splash:with_timeout(function()\n            splash:wait(0.5)\n            return 1, 2, 3\n        end, 1)\n\n        return result1, result2, result3\n    end\n\nNote that if the specified timeout period elapsed Splash will try to\ninterrupt the running function. However, Splash scripts are executed\nin `cooperative multitasking`_ manner and because of that sometimes\nSplash won't be able to stop your running function upon timeout expiration.\nIn two words, cooperative multitasking means that the managing program\n(in our example, it is Splash scripting engine) won't stop the running\nfunction if it doesn't *ask* for that. In Splash scripting the running\nfunction can be interrupted only if some *async* operation was called.\nOn the contrary, non of the *sync* operations can be interrupted.\n\n.. note::\n\n    Splash scripts are executing in `cooperative multitasking`_ manner.\n    You should be careful while running sync functions.\n\nLet's see the difference in examples.\n\nExample 3:\n\n.. code-block:: lua\n\n    function main(splash)\n        local ok, result = splash:with_timeout(function()\n            splash:go(splash.args.url) -- during this operation the current function can be stopped\n            splash:evaljs(long_js_operation) -- during JS function evaluation the function cannot be stopped\n            local png = splash:png() -- sync operation and during it the function cannot be stopped\n            return png\n        end, 0.1)\n\n        return result\n    end\n.. _cooperative multitasking: https://en.wikipedia.org/wiki/Cooperative_multitasking",
    "params": "* func - the function to run\n* timeout - timeout, in seconds"
  },
  "splash:send_keys": {
    "name": "send_keys",
    "header": "splash:send_keys",
    "content": "Send keyboard events to page context.\n\n**Signature:** ``splash:send_keys(keys)``\n\n**Parameters**\n\n* keys - string representing the keys to be sent as keyboard events.\n\n**Returns:** nil\n\n**Async:** no.\n\nKey sequences are specified by using a small subset of emacs edmacro syntax:\n\n* whitespace is ignored and only used to separate the different keys\n* characters are literally represented\n* words within brackets represent function keys, like ``<Return>``, ``<Left>``\n  or ``<Home>``. See `Qt docs`__ for a full list of function keys. ``<Foo>``\n  will try to match ``Qt::Key_Foo``.\n\n__ http://doc.qt.io/qt-5/qt.html#Key-enum\n\nFollowing table shows some examples of macros and what they would generate on\nan input:\n\n============================    ===============\nMacro                           Result\n============================    ===============\n``Hello World``                 ``HelloWorld``\n``Hello <Space> World``         ``Hello World``\n``< S p a c e >``               ``<Space>``\n``Hello <Home> <Delete>``       ``ello``\n``Hello <Backspace>``           ``Hell``\n============================    ===============\n\nKey events are not propagated immediately until event loop regains control,\nthus :ref:`splash-wait` must be called to reflect the events.\n\nSee also: :ref:`splash-element-send-keys`, :ref:`splash-send-text`.\n\n.. _Qt key-enum: http://doc.qt.io/qt-5/qt.html#Key-enum",
    "short": "Send keyboard events to page context.",
    "signature": "splash:send_keys(keys)",
    "returns": "nil",
    "async": "no.",
    "details": "Key sequences are specified by using a small subset of emacs edmacro syntax:\n\n* whitespace is ignored and only used to separate the different keys\n* characters are literally represented\n* words within brackets represent function keys, like ``<Return>``, ``<Left>``\n  or ``<Home>``. See `Qt docs`__ for a full list of function keys. ``<Foo>``\n  will try to match ``Qt::Key_Foo``.\n\n__ http://doc.qt.io/qt-5/qt.html#Key-enum\n\nFollowing table shows some examples of macros and what they would generate on\nan input:\n\n============================    ===============\nMacro                           Result\n============================    ===============\n``Hello World``                 ``HelloWorld``\n``Hello <Space> World``         ``Hello World``\n``< S p a c e >``               ``<Space>``\n``Hello <Home> <Delete>``       ``ello``\n``Hello <Backspace>``           ``Hell``\n============================    ===============\n\nKey events are not propagated immediately until event loop regains control,\nthus :ref:`splash-wait` must be called to reflect the events.\n\nSee also: :ref:`splash-element-send-keys`, :ref:`splash-send-text`.\n\n.. _Qt key-enum: http://doc.qt.io/qt-5/qt.html#Key-enum",
    "params": null
  },
  "splash:send_text": {
    "name": "send_text",
    "header": "splash:send_text",
    "content": "Send text as input to page context, literally, character by character.\n\n**Signature:** ``splash:send_text(text)``\n\n**Parameters:**\n\n* text - string to be sent as input.\n\n**Returns:** nil\n\n**Async:** no.\n\nKey events are not propagated immediately until event loop regains control,\nthus :ref:`splash-wait` must be called to reflect the events.\n\nThis function in conjuction with :ref:`splash-send-keys` covers most needs on\nkeyboard input, such as filling in forms and submitting them.\n\nExample 1: focus first input, fill in a form and submit\n\n.. code-block:: lua\n\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        assert(splash:wait(0.5))\n        splash:send_keys(\"<Tab>\")\n        splash:send_text(\"zero cool\")\n        splash:send_keys(\"<Tab>\")\n        splash:send_text(\"hunter2\")\n        splash:send_keys(\"<Return>\")\n        -- note how this could be translated to\n        -- splash:send_keys(\"<Tab> zero <Space> cool <Tab> hunter2 <Return>\")\n        assert(splash:wait(0))\n        -- ...\n    end\n\nExample 2: focus inputs with javascript or :ref:`splash-mouse-click`\n\nWe can't always assume that a `<Tab>` will focus the input we want or an\n`<Enter>` will submit a form. Selecting an input can either be accomplished\nby focusing it or by clicking it. Submitting a form can also be done by\nfiring a submit event on the form, or simply by clicking on the submit button.\n\nThe following example will focus an input, fill in a form and click on the\nsubmit button using :ref:`splash-mouse-click`. It assumes there are two\narguments passed to splash, `username` and `password`.\n\n.. code-block:: lua\n\n    function main(splash, args)\n        function focus(sel)\n            splash:select(sel):focus()\n        end\n\n        assert(splash:go(args.url))\n        assert(splash:wait(0.5))\n        focus('input[name=username]')\n        splash:send_text(args.username)\n        assert(splash:wait(0))\n        focus('input[name=password]')\n        splash:send_text(args.password)\n        splash:select('input[type=submit]'):mouse_click()\n        assert(splash:wait(0))\n        -- Usually, wait for the submit request to finish\n        -- ...\n    end\n\nSee also: :ref:`splash-element-send-text`, :ref:`splash-send-keys`.",
    "short": "Send text as input to page context, literally, character by character.",
    "signature": "splash:send_text(text)",
    "returns": "nil",
    "async": "no.",
    "details": "Key events are not propagated immediately until event loop regains control,\nthus :ref:`splash-wait` must be called to reflect the events.\n\nThis function in conjuction with :ref:`splash-send-keys` covers most needs on\nkeyboard input, such as filling in forms and submitting them.\n\nExample 1: focus first input, fill in a form and submit\n\n.. code-block:: lua\n\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        assert(splash:wait(0.5))\n        splash:send_keys(\"<Tab>\")\n        splash:send_text(\"zero cool\")\n        splash:send_keys(\"<Tab>\")\n        splash:send_text(\"hunter2\")\n        splash:send_keys(\"<Return>\")\n        -- note how this could be translated to\n        -- splash:send_keys(\"<Tab> zero <Space> cool <Tab> hunter2 <Return>\")\n        assert(splash:wait(0))\n        -- ...\n    end\n\nExample 2: focus inputs with javascript or :ref:`splash-mouse-click`\n\nWe can't always assume that a `<Tab>` will focus the input we want or an\n`<Enter>` will submit a form. Selecting an input can either be accomplished\nby focusing it or by clicking it. Submitting a form can also be done by\nfiring a submit event on the form, or simply by clicking on the submit button.\n\nThe following example will focus an input, fill in a form and click on the\nsubmit button using :ref:`splash-mouse-click`. It assumes there are two\narguments passed to splash, `username` and `password`.\n\n.. code-block:: lua\n\n    function main(splash, args)\n        function focus(sel)\n            splash:select(sel):focus()\n        end\n\n        assert(splash:go(args.url))\n        assert(splash:wait(0.5))\n        focus('input[name=username]')\n        splash:send_text(args.username)\n        assert(splash:wait(0))\n        focus('input[name=password]')\n        splash:send_text(args.password)\n        splash:select('input[type=submit]'):mouse_click()\n        assert(splash:wait(0))\n        -- Usually, wait for the submit request to finish\n        -- ...\n    end\n\nSee also: :ref:`splash-element-send-text`, :ref:`splash-send-keys`.",
    "params": "* text - string to be sent as input."
  },
  "splash:select": {
    "name": "select",
    "header": "splash:select",
    "content": "Select the first HTML element from DOM of the current web page that\nmatches the specified CSS selector.\n\n**Signature:** ``element = splash:select(selector)``\n\n**Parameters:**\n\n* selector - valid CSS selector\n\n**Returns:** an :ref:`Element <splash-element>` object.\n\n**Async:** no.\n\nUsing :ref:`splash-select` you can get the element that matches your\nspecified CSS selector like using `document.querySelector`_ in the browser.\nThe returned element is an :ref:`splash-element` which has many useful\nmethods and almost all methods and attributes that element has in JavaScript.\n\nIf the element cannot be found using the specified selector ``nil`` will\nbe returned. If your selector is not a valid CSS selector an error will\nbe raised.\n\nExample 1: select an element which has ``element`` class and return class\nnames off all the siblings of the specified element.\n\n.. code-block:: lua\n\n    local treat = require('treat')\n\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        assert(splash:wait(0.5))\n\n        local el = splash:select('.element')\n        local seen = {}\n        local classNames = {}\n\n        while el do\n          local classList = el.node.classList\n          if classList then\n            for _, v in ipairs(classList) do\n              if (not seen[v]) then\n                classNames[#classNames + 1] = v\n                seen[v] = true\n              end\n            end\n          end\n\n          el = el.node.nextSibling\n        end\n\n        return treat.as_array(classNames)\n    end\n\n\nExample 2: assert that the returned element exists\n\n.. code-block:: lua\n\n    function main(splash)\n        -- ...\n        local el = assert(splash:select('.element'))\n        -- ...\n    end\n\n\n.. _document.querySelector: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector",
    "short": "Select the first HTML element from DOM of the current web page that\nmatches the specified CSS selector.",
    "signature": "element = splash:select(selector)",
    "returns": "an :ref:`Element <splash-element>` object.",
    "async": "no.",
    "details": "Using :ref:`splash-select` you can get the element that matches your\nspecified CSS selector like using `document.querySelector`_ in the browser.\nThe returned element is an :ref:`splash-element` which has many useful\nmethods and almost all methods and attributes that element has in JavaScript.\n\nIf the element cannot be found using the specified selector ``nil`` will\nbe returned. If your selector is not a valid CSS selector an error will\nbe raised.\n\nExample 1: select an element which has ``element`` class and return class\nnames off all the siblings of the specified element.\n\n.. code-block:: lua\n\n    local treat = require('treat')\n\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        assert(splash:wait(0.5))\n\n        local el = splash:select('.element')\n        local seen = {}\n        local classNames = {}\n\n        while el do\n          local classList = el.node.classList\n          if classList then\n            for _, v in ipairs(classList) do\n              if (not seen[v]) then\n                classNames[#classNames + 1] = v\n                seen[v] = true\n              end\n            end\n          end\n\n          el = el.node.nextSibling\n        end\n\n        return treat.as_array(classNames)\n    end\n\n\nExample 2: assert that the returned element exists\n\n.. code-block:: lua\n\n    function main(splash)\n        -- ...\n        local el = assert(splash:select('.element'))\n        -- ...\n    end\n\n\n.. _document.querySelector: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector",
    "params": "* selector - valid CSS selector"
  },
  "splash:select_all": {
    "name": "select_all",
    "header": "splash:select_all",
    "content": "Select the list of HTML elements from DOM of the current web page\nthat match the specified CSS selector.\n\n**Signature:** ``elements = splash:select_all(selector)``\n\n**Parameters:**\n\n* selector - valid CSS selector\n\n**Returns:** a list of :ref:`Element <splash-element>` objects.\n\n**Async:** no.\n\nThis method differs from :ref:`splash-select` by returning the *all*\nelements in a table that match the specified selector.\n\nIf no elements can be found using the specified selector ``{}`` is\nreturned. If the selector is not a valid CSS selector an error is raised.\n\nExample: select all ``<img />`` elements and get their ``src`` attributes\n\n.. code-block:: lua\n\n    local treat = require('treat')\n\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        assert(splash:wait(0.5))\n\n        local imgs = splash:select_all('img')\n        local srcs = {}\n\n        for _, img in ipairs(imgs) do\n          srcs[#srcs+1] = img.node.attributes.src\n        end\n\n        return treat.as_array(srcs)\n    end",
    "short": "Select the list of HTML elements from DOM of the current web page\nthat match the specified CSS selector.",
    "signature": "elements = splash:select_all(selector)",
    "returns": "a list of :ref:`Element <splash-element>` objects.",
    "async": "no.",
    "details": "This method differs from :ref:`splash-select` by returning the *all*\nelements in a table that match the specified selector.\n\nIf no elements can be found using the specified selector ``{}`` is\nreturned. If the selector is not a valid CSS selector an error is raised.\n\nExample: select all ``<img />`` elements and get their ``src`` attributes\n\n.. code-block:: lua\n\n    local treat = require('treat')\n\n    function main(splash)\n        assert(splash:go(splash.args.url))\n        assert(splash:wait(0.5))\n\n        local imgs = splash:select_all('img')\n        local srcs = {}\n\n        for _, img in ipairs(imgs) do\n          srcs[#srcs+1] = img.node.attributes.src\n        end\n\n        return treat.as_array(srcs)\n    end",
    "params": "* selector - valid CSS selector"
  }
}